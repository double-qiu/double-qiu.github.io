<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Redis 和 Memcached 的区别]]></title>
      <url>http://ufdouble.com/2016/07/04/Redis%E5%92%8CMemcached%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Redis 的作者 Salvatore Sanfilippo 曾经对这两种基于内存的数据存储系统进行过比较：</p>
</blockquote>
<ol>
<li>Redis支持服务器端的数据操作：Redis相比Memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在Memcached里，你需要将数据拿到客户端来进行类似的修改再set回去。这大大增加了网络IO的次数和数据体积。在Redis中，这些复杂的操作通常和一般的GET/SET一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么Redis会是不错的选择。<br>内存使用效率对比：使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。<br>性能对比：由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起Memcached，还是稍有逊色。<br>具体为什么会出现上面的结论，以下为收集到的资料：</li>
<li>内存使用效率对比：使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。</li>
<li>性能对比：由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起Memcached，还是稍有逊色。</li>
</ol>
<p>具体为什么会出现上面的结论，以下为收集到的资料：</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[测试驱动开发（TDD）]]></title>
      <url>http://ufdouble.com/2016/07/04/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91TDD/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote>
<p>一个高效的软件开发过程对软件开发人员来说是至关重要的，决定着开发是痛苦的挣扎，还是不断进步的喜悦。国人对软件蓝领的不屑，对繁琐冗长的传统开发过程的不耐，使大多数开发人员无所适从。最近兴起的一些软件开发过程相关的技术，提供一些比较高效、实用的软件过程开发方法。其中比较基础、关键的一个技术就是测试驱动开发（Test-Driven Development）。虽然TDD光大于极限编程，但测试驱动开发完全可以单独应用。下面就从开发人员使用的角度进行介绍，使开发人员用最少的代价尽快理解、掌握、应用这种技术。下面分优势，原理，过程，原则，测试技术，Tips等方面进行讨论</p>
</blockquote>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>TDD的基本思路就是通过测试来推动整个开发的进行。而测试驱动开发技术并不只是单纯的测试工作。</p>
<p>需求向来就是软件开发过程中感觉最不好明确描述、易变的东西。这里说的需求不只是指用户的需求，还包括对代码的使用需求。很多开发人员最害怕的就是后期还要修改某个类或者函数的接口进行修改或者扩展，为什么会发生这样的事情就是因为这部分代码的使用需求没有很好的描述。测试驱动开发就是通过编写测试用例，先考虑代码的使用需求（包括功能、过程、接口等），而且这个描述是无二义的，可执行验证的。</p>
<p>通过编写这部分代码的测试用例，对其功能的分解、使用过程、接口都进行了设计。而且这种从使用角度对代码的设计通常更符合后期开发的需求。可测试的要求，对代码的内聚性的提高和复用都非常有益。因此测试驱动开发也是一种代码设计的过程。</p>
<p>开发人员通常对编写文档非常厌烦，但要使用、理解别人的代码时通常又希望能有文档进行指导。而测试驱动开发过程中产生的测试用例代码就是对代码的最好的解释。</p>
<p>快乐工作的基础就是对自己有信心，对自己的工作成果有信心。当前很多开发人员却经常在担心：“代码是否正确？”“辛苦编写的代码还有没有严重bug？”“修改的新代码对其他部分有没有影响？”。这种担心甚至导致某些代码应该修改却不敢修改的地步。测试驱动开发提供的测试集就可以作为你信心的来源。</p>
<p>当然测试驱动开发最重要的功能还在于保障代码的正确性，能够迅速发现、定位bug。而迅速发现、定位bug是很多开发人员的梦想。针对关键代码的测试集，以及不断完善的测试用例，为迅速发现、定位bug提供了条件。</p>
<p>我的一段功能非常复杂的代码使用TDD开发完成，真实环境应用中只发现几个bug，而且很快被定位解决。您在应用后，也一定会为那种自信的开发过程，功能不断增加、完善的感觉，迅速发现、定位bug的能力所感染，喜欢这个技术的。</p>
<p>那么是什么样的原理、方法提供上面说的这些好处哪？下面我们就看看TDD的原理。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>测试驱动开发的基本思想就是在开发功能代码之前，先编写测试代码。也就是说在明确要开发某个功能后，首先思考如何对这个功能进行测试，并完成测试代码的编写，然后编写相关的代码满足这些测试用例。然后循环进行添加其他功能，直到完全部功能的开发。</p>
<p>我们这里把这个技术的应用领域从代码编写扩展到整个开发过程。应该对整个开发过程的各个阶段进行测试驱动，首先思考如何对这个阶段进行测试、验证、考核，并编写相关的测试文档，然后开始下一步工作，最后再验证相关的工作。下图是一个比较流行的测试模型：V测试模型。<br><img src="http://i.imgur.com/IbMQX1V.jpg" alt=""></p>
<p>在开发的各个阶段，包括需求分析、概要设计、详细设计、编码过程中都应该考虑相对应的测试工作，完成相关的测试用例的设计、测试方案、测试计划的编写。这里提到的开发阶段只是举例，根据实际的开发活动进行调整。相关的测试文档也不一定是非常详细复杂的文档，或者什么形式，但应该养成测试驱动的习惯。</p>
<p>关于测试模型，还有X测试模型。这个测试模型，我认为，是对详细阶段和编码阶段进行建模，应该说更详细的描述了详细设计和编码阶段的开发行为。及针对某个功能进行对应的测试驱动开发。</p>
<p><img src="http://i.imgur.com/XsKqinL.jpg" alt=""></p>
<p>基本原理应该说非常简单，那么如何进行实际操作哪，下面对开发过程进行详细的介绍。</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>软件开发其他阶段的测试驱动开发，根据测试驱动开发的思想完成对应的测试文档即可。下面针对详细设计和编码阶段进行介绍。</p>
<p>测试驱动开发的基本过程如下：</p>
<p>1） 明确当前要完成的功能。可以记录成一个 TODO 列表。</p>
<p>2） 快速完成针对此功能的测试用例编写。</p>
<p>3） 测试代码编译不通过。</p>
<p>4） 编写对应的功能代码。</p>
<p>5） 测试通过。</p>
<p>6） 对代码进行重构，并保证测试通过。</p>
<p>7） 循环完成所有功能的开发。</p>
<p>为了保证整个测试过程比较快捷、方便，通常可以使用测试框架组织所有的测试用例。一个免费的、优秀的测试框架是 Xunit 系列，几乎所有的语言都有对应的测试框架。我曾经写过一篇文章介绍CppUnit的文章（ <a href="http://www.ibm.com/developerworks/cn/linux/l-cppunit/index.html）。" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/linux/l-cppunit/index.html）。</a></p>
<p>开发过程中，通常把测试代码和功能代码分开存放，这里提供一个简单的测试框架使用例子，您可以通过它了解测试框架的使用。下面是文件列表。</p>
<pre><code>project/                项目主目录
project/test            测试项目主目录
project/test/testSeq.cpp        测试seq_t 的测试文件，对其他功能文件的测试文件复制后修改即可
project/test/testSeq.h
project/test/Makefile            测试项目的 Makefile 
project/test/main.cpp            测试项目的主文件，不需要修改
project/main.cpp                   项目的主文件
project/seq_t.h            功能代码，被测试文件
project/Makefile                   项目的 Makefile
</code></pre><p>主要流程基本如此，但要让你的代码很容易的进行测试，全面又不繁琐的进行测试，还是有很多测试原则和技术需要考虑。</p>
<h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p>测试隔离。不同代码的测试应该相互隔离。对一块代码的测试只考虑此代码的测试，不要考虑其实现细节（比如它使用了其他类的边界条件）。</p>
<p>一顶帽子。开发人员开发过程中要做不同的工作，比如：编写测试代码、开发功能代码、对代码重构等。做不同的事，承担不同的角色。开发人员完成对应的工作时应该保持注意力集中在当前工作上，而不要过多的考虑其他方面的细节，保证头上只有一顶帽子。避免考虑无关细节过多，无谓地增加复杂度。</p>
<p>测试列表。需要测试的功能点很多。应该在任何阶段想添加功能需求问题时，把相关功能点加到测试列表中，然后继续手头工作。然后不断的完成对应的测试用例、功能代码、重构。一是避免疏漏，也避免干扰当前进行的工作。</p>
<p>测试驱动。这个比较核心。完成某个功能，某个类，首先编写测试代码，考虑其如何使用、如何测试。然后在对其进行设计、编码。</p>
<p>先写断言。测试代码编写时，应该首先编写对功能代码的判断用的断言语句，然后编写相应的辅助语句。</p>
<p>可测试性。功能代码设计、开发时应该具有较强的可测试性。其实遵循比较好的设计原则的代码都具备较好的测试性。比如比较高的内聚性，尽量依赖于接口等。</p>
<p>及时重构。无论是功能代码还是测试代码，对结构不合理，重复的代码等情况，在测试通过后，及时进行重构。关于重构，我会另撰文详细分析。<br>小步前进。软件开发是个复杂性非常高的工作，开发过程中要考虑很多东西，包括代码的正确性、可扩展性、性能等等，很多问题都是因为复杂性太大导致的。极限编程提出了一个非常好的思路就是小步前进。把所有的规模大、复杂性高的工作，分解成小的任务来完成。对于一个类来说，一个功能一个功能的完成，如果太困难就再分解。每个功能的完成就走测试代码－功能代码－测试－重构的循环。通过分解降低整个系统开发的复杂性。这样的效果非常明显。几个小的功能代码完成后，大的功能代码几乎是不用调试就可以通过。一个个类方法的实现，很快就看到整个类很快就完成啦。本来感觉很多特性需要增加，很快就会看到没有几个啦。你甚至会为这个速度感到震惊。（我理解，是大幅度减少调试、出错的时间产生的这种速度感）</p>
<h2 id="测试技术"><a href="#测试技术" class="headerlink" title="测试技术"></a>测试技术</h2><h3 id="测试范围、粒度"><a href="#测试范围、粒度" class="headerlink" title="测试范围、粒度"></a>测试范围、粒度</h3><p>对哪些功能进行测试？会不会太繁琐？什么时候可以停止测试？这些问题比较常见。按大师 Kent Benk 的话，对那些你认为应该测试的代码进行测试。就是说，要相信自己的感觉，自己的经验。那些重要的功能、核心的代码就应该重点测试。感到疲劳就应该停下来休息一下。感觉没有必要更详细的测试，就停止本轮测试。<br>测试驱动开发强调测试并不应该是负担，而应该是帮助我们减轻工作量的方法。而对于何时停止编写测试用例，也是应该根据你的经验，功能复杂、核心功能的代码就应该编写更全面、细致的测试用例，否则测试流程即可。<br>测试范围没有静态的标准，同时也应该可以随着时间改变。对于开始没有编写足够的测试的功能代码，随着bug的出现，根据bug补齐相关的测试用例即可。<br>小步前进的原则，要求我们对大的功能块测试时，应该先分拆成更小的功能块进行测试，比如一个类A使用了类B、C，就应该编写到A使用B、C功能的测试代码前，完成对B、C的测试和开发。那么是不是每个小类或者小函数都应该测试哪？我认为没有必要。你应该运用你的经验，对那些可能出问题的地方重点测试，感觉不可能出问题的地方就等它真正出问题的时候再补测试吧。</p>
<h3 id="怎么编写测试用例"><a href="#怎么编写测试用例" class="headerlink" title="怎么编写测试用例"></a>怎么编写测试用例</h3><p>测试用例的编写就用上了传统的测试技术。</p>
<p>操作过程尽量模拟正常使用的过程。</p>
<p>全面的测试用例应该尽量做到分支覆盖，核心代码尽量做到路径覆盖。</p>
<p>测试数据尽量包括：真实数据、边界数据。</p>
<p>测试语句和测试数据应该尽量简单，容易理解。</p>
<p>为了避免对其他代码过多的依赖，可以实现简单的桩函数或桩类（Mock Object）。</p>
<p>如果内部状态非常复杂或者应该判断流程而不是状态，可以通过记录日志字符串的方式进行验证。</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>很多朋友有疑问，“测试代码的正确性如何保障？是写测试代码还是写测试文档？”这样是不是会陷入“鸡生蛋，蛋生鸡”的循环。其实是不会的。通常测试代码通常是非常简单的，通常围绕着某个情况的正确性判断的几个语句，如果太复杂，就应该继续分解啦。而传统的开发过程通常强调测试文档。但随着开发节奏的加快，用户需求的不断变化，维护高层（需求、概要设计）的测试文档可以，更低层的测试文档的成本的确太大了。而且可实时验证功能正确性的测试代码就是对代码最好的文档。</p>
<p>软件开发过程中，除了遵守上面提到的测试驱动开发的几个原则外，一个需要注意的问题就是，谨防过度设计。编写功能代码时应该关注于完成当前功能点，通过测试，使用最简单、直接的方式来编码。过多的考虑后期的扩展，其他功能的添加，无疑增加了过多的复杂性，容易产生问题。应该等到要添加这些特性时在进行详细的测试驱动开发。到时候，有整套测试用例做基础，通过不断重构很容易添加相关特性。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[敏捷开发]]></title>
      <url>http://ufdouble.com/2016/07/04/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/</url>
      <content type="html"><![CDATA[<blockquote>
<p>现在敏捷开发是越来越火了，人人都在谈敏捷，人人都在学习Scrum和XP…</p>
<p>为了不落后他人，于是我也开始学习Scrum，今天主要是对我最近阅读的相关资料，根据自己的理解，用自己的话来讲述Scrum中的各个环节，主要目的有两个，一个是进行知识的总结，另外一个是觉得网上很多学习资料的讲述方式让初学者不太容易理解；所以我决定写一篇扫盲性的博文，同时试着也与园内的朋友一起分享交流一下，希望对初学者有帮助。</p>
</blockquote>
<h2 id="什么是敏捷开发？"><a href="#什么是敏捷开发？" class="headerlink" title="什么是敏捷开发？"></a>什么是敏捷开发？</h2><p>敏捷开发(Agile Development)是一种以人为核心、迭代、循序渐进的开发方法。<br>怎么理解呢？首先，我们要理解它不是一门技术，它是一种开发方法，也就是一种软件开发的流程，它会指导我们用规定的环节去一步一步完成项目的开发；而这种开发方式的主要驱动核心是人；它采用的是迭代式开发；</p>
<h2 id="为什么说是以人为核心？"><a href="#为什么说是以人为核心？" class="headerlink" title="为什么说是以人为核心？"></a>为什么说是以人为核心？</h2><p>我们大部分人都学过瀑布开发模型，它是以文档为驱动的，为什么呢？因为在瀑布的整个开发过程中，要写大量的文档，把需求文档写出来后，开发人员都是根据文档进行开发的，一切以文档为依据；而敏捷开发它只写有必要的文档，或尽量少写文档，敏捷开发注重的是人与人之间，面对面的交流，所以它强调以人为核心。</p>
<h2 id="什么是迭代？"><a href="#什么是迭代？" class="headerlink" title="什么是迭代？"></a>什么是迭代？</h2><p>迭代是指把一个复杂且开发周期很长的开发任务，分解为很多小周期可完成的任务，这样的一个周期就是一次迭代的过程；同时每一次迭代都可以生产或开发出一个可以交付的软件产品。</p>
<h2 id="关于Scrum和XP"><a href="#关于Scrum和XP" class="headerlink" title="关于Scrum和XP"></a>关于Scrum和XP</h2><p>前面说了敏捷它是一种指导思想或开发方式，但是它没有明确告诉我们到底采用什么样的流程进行开发，而Scrum和XP就是敏捷开发的具体方式了，你可以采用Scrum方式也可以采用XP方式；Scrum和XP的区别是，Scrum偏重于过程，XP则偏重于实践，但是实际中，两者是结合一起应用的，这里我主要讲Scrum。</p>
<h2 id="什么是Scrum？"><a href="#什么是Scrum？" class="headerlink" title="什么是Scrum？"></a>什么是Scrum？</h2><p>Scrum的英文意思是橄榄球运动的一个专业术语，表示“争球”的动作；把一个开发流程的名字取名为Scrum，我想你一定能想象出你的开发团队在开发一个项目时，大家像打橄榄球一样迅速、富有战斗激情、人人你争我抢地完成它，你一定会感到非常兴奋的。<br>而Scrum就是这样的一个开发流程，运用该流程，你就能看到你团队高效的工作。</p>
<h2 id="【Scrum开发流程中的三大角色】"><a href="#【Scrum开发流程中的三大角色】" class="headerlink" title="【Scrum开发流程中的三大角色】"></a>【Scrum开发流程中的三大角色】</h2><h3 id="产品负责人（Product-Owner）"><a href="#产品负责人（Product-Owner）" class="headerlink" title="产品负责人（Product Owner）"></a>产品负责人（Product Owner）</h3><p>主要负责确定产品的功能和达到要求的标准，指定软件的发布日期和交付的内容，同时有权力接受或拒绝开发团队的工作成果。</p>
<h3 id="流程管理员（Scrum-Master）"><a href="#流程管理员（Scrum-Master）" class="headerlink" title="流程管理员（Scrum Master）"></a>流程管理员（Scrum Master）</h3><p>主要负责整个Scrum流程在项目中的顺利实施和进行，以及清除挡在客户和开发工作之间的沟通障碍，使得客户可以直接驱动开发。</p>
<h3 id="开发团队（Scrum-Team）"><a href="#开发团队（Scrum-Team）" class="headerlink" title="开发团队（Scrum Team）"></a>开发团队（Scrum Team）</h3><p>主要负责软件产品在Scrum规定流程下进行开发工作，人数控制在5~10人左右，每个成员可能负责不同的技术方面，但要求每成员必须要有很强的自我管理能力，同时具有一定的表达能力；成员可以采用任何工作方式，只要能达到Sprint的目标。</p>
<p><strong>Scrum流程图</strong><br><img src="http://i.imgur.com/LRdmK1w.jpg" alt=""></p>
<p>下面，我们开始讲具体实施流程，但是在讲之前，我还要对一个英文单词进行讲解。</p>
<h2 id="什么是Sprint？"><a href="#什么是Sprint？" class="headerlink" title="什么是Sprint？"></a>什么是Sprint？</h2><p>Sprint是短距离赛跑的意思，这里面指的是一次迭代，而一次迭代的周期是1个月时间（即4个星期），也就是我们要把一次迭代的开发内容以最快的速度完成它，这个过程我们称它为Sprint。</p>
<h2 id="如何进行Scrum开发？"><a href="#如何进行Scrum开发？" class="headerlink" title="如何进行Scrum开发？"></a>如何进行Scrum开发？</h2><ol>
<li><p>我们首先需要确定一个Product Backlog（按优先顺序排列的一个产品需求列表），这个是由Product Owner 负责的；</p>
</li>
<li><p>Scrum Team根据Product Backlog列表，做工作量的预估和安排；</p>
</li>
<li><p>有了Product Backlog列表，我们需要通过 Sprint Planning Meeting（Sprint计划会议） 来从中挑选出一个Story作为本次迭代完成的目标，这个目标的时间周期是1~4个星期，然后把这个Story进行细化，形成一个Sprint Backlog；</p>
</li>
<li><p>Sprint Backlog是由Scrum Team去完成的，每个成员根据Sprint Backlog再细化成更小的任务（细到每个任务的工作量在2天内能完成）</p>
</li>
<li><p>在Scrum Team完成计划会议上选出的Sprint Backlog过程中，需要进行 Daily Scrum Meeting（每日站立会议），每次会议控制在15分钟左右，每个人都必须发言，并且要向所有成员当面汇报你昨天完成了什么，并且向所有成员承诺你今天要完成什么，同时遇到不能解决的问题也可以提出，每个人回答完成后，要走到黑板前更新自己的 Sprint burn down（Sprint燃尽图）；</p>
</li>
<li><p>做到每日集成，也就是每天都要有一个可以成功编译、并且可以演示的版本；很多人可能还没有用过自动化的每日集成，其实TFS就有这个功能，它可以支持每次有成员进行签入操作的时候，在服务器上自动获取最新版本，然后在服务器中编译，如果通过则马上再执行单元测试代码，如果也全部通过，则将该版本发布，这时一次正式的签入操作才保存到TFS中，中间有任何失败，都会用邮件通知项目管理人员；</p>
</li>
<li><p>当一个Story完成，也就是Sprint Backlog被完成，也就表示一次Sprint完成，这时，我们要进行 Srpint Review Meeting（演示会议），也称为评审会议，产品负责人和客户都要参加（最好本公司老板也参加），每一个Scrum Team的成员都要向他们演示自己完成的软件产品（这个会议非常重要，一定不能取消）；</p>
</li>
<li><p>最后就是 Sprint Retrospective Meeting（回顾会议），也称为总结会议，以轮流发言方式进行，每个人都要发言，总结并讨论改进的地方，放入下一轮Sprint的产品需求中；</p>
</li>
</ol>
<p><strong>下面是运用Scrum开发流程中的一些场景图：</strong><br><img src="http://i.imgur.com/3462EkG.png" alt=""></p>
<p>上图是一个 Product Backlog 的示例。</p>
<p><img src="http://i.imgur.com/o2KWOy1.png" alt=""></p>
<p>上图就是每日的站立会议了，参会人员可以随意姿势站立，任务看板要保证让每个人看到，当每个人发言完后，要走到任务版前更新自己的燃尽图。</p>
<p><img src="http://i.imgur.com/PDe0XDO.png" alt=""></p>
<p>任务看版包含 未完成、正在做、已完成 的工作状态，假设你今天把一个未完成的工作已经完成，那么你要把小卡片从未完成区域贴到已完成区域。</p>
<p><img src="http://i.imgur.com/iaCmWmj.png" alt=""></p>
<p>每个人的工作进度和完成情况都是公开的，如果有一个人的工作任务在某一个位置放了好几天，大家都能发现他的工作进度出现了什么问题（成员人数最好是5~7个，这样每人可以使用一种专用颜色的标签纸，一眼就可以从任务版看出谁的工作进度快，谁的工作进度慢）</p>
<p><img src="http://i.imgur.com/nFVvNbr.png" alt=""></p>
<p>上图可不是扑克牌，它是计划纸牌，它的作用是防止项目在开发过程中，被某些人所领导。</p>
<p>怎么用的呢？比如A程序员开发一个功能，需要5个小时，B程序员认为只需要半小时，那他们各自取相应的牌，藏在手中，最后摊牌，如果时间差距很大，那么A和B就可以讨论A为什么要5个小时…</p>
<p><strong>敏捷开发的4句宣言</strong></p>
<p>个体与交互 胜过 过程与工具</p>
<p>可以工作的软件 胜过 面面俱到的文挡</p>
<p>客户协作 胜过 合同谈判</p>
<p>响应变化 胜过 遵循计划</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[nginx缓存静态文件搭建详解]]></title>
      <url>http://ufdouble.com/2016/07/04/nginx%E7%BC%93%E5%AD%98%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<blockquote>
<p>nginx缓存静态文件</p>
</blockquote>
<p>接触nginx的兄弟或多或少都有遇到缓存问题，要么是nginx为什么不缓存，要么就是nginx缓存很快就失效等等问题，在网上找了一遍nginx缓存优先级的文章，大家可以参考下。</p>
<h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p>client端  &lt;——————&gt;   nginx cache &lt;——————&gt;源服务器</p>
<p>经过大量测试发现：nginx的过期顺序是有一个优先级的。下面首先说明各个影响缓存过期的因素：</p>
<p>（1）inactive:在proxy_cache_path配置项中进行配置，说明某个缓存在inactive指定的时间内如果不访问，将会从缓存中删除。</p>
<p>（2）源服务器php页面中生成的响应头中的Expires，生成语句为：header(“Expires: Fri, 07 Sep 2013 08:05:18 GMT”);</p>
<p>（3）源服务器php页面生成的max-age，生成语句为：header(“Cache-Control: max-age=60”);</p>
<p>（4）nginx的配置项 proxy_cache_valid:配置nginx cache中的缓存文件的缓存时间，如果配置项为：proxy_cache_valid 200 304 2m;说<br>明对于状态为200和304的缓存文件的缓存时间是2分钟，两分钟之后再访问该缓存文件时，文件会过期，从而去源服务器重新取数据。<br>其次对需要注意的一点：源服务器的expires和nginx cache的expires配置项的冲突进行说明，场景如下</p>
<p>（1）源服务器端有php文件ta1.php内容如下：</p>
<pre><code>&lt;?php
header(&quot;Expires: Fri, 07 Sep 2013 08:05:18 GMT&quot;);
header(&quot;Last-Modified: &quot;.gmdate(&quot;D, d M Y H:i:s&quot;).&quot; GMT&quot;);
header(&quot;Cache-Control: max-age=60&quot;);
echo&quot;ta1&quot;;
?&gt;
</code></pre><p>（2）在nginx cache服务器端的配置信息如下：</p>
<pre><code>…….
proxy_cache_path /data0/proxy_cache_dir levels=1:2  keys_zone=cache_one:200minactive=5smax_size=30g;
……..

location~.*\.(php|jsp|cgi)$
{
   proxy_read_timeout10s;
   proxy_connect_timeout10s;
   proxy_set_header Host$host;
   proxy_cache_use_stale updating;
   proxy_cache_key$host$uri$is_args$args;
   proxy_cache cache_one;
   #proxy_ignore_headers &quot;Cache-Control&quot;;
   #proxy_hide_header &quot;Cache-Control&quot;;
   #proxy_ignore_headers &quot;Expires&quot;;
   #proxy_hide_header &quot;Expires&quot;;
   proxy_hide_header&quot;Set-Cookie&quot;;
   proxy_ignore_headers&quot;Set-Cookie&quot;;
   #add_header Cache-Control max-age=60;
   add_headerX-Cache&apos;$upstream_cache_status from $server_addr&apos;;
   proxy_cache_valid2003042m;
   #proxy_cache_valid any 0m;
   proxy_pass http://backend_server;
   expires30s;
}
………….
</code></pre><p>从上面两项可以看出nginx cache 服务器中expires的配置是30s，该expires的值直接决定了在浏览器端看到的max-age以及expires的值。而源服务器断的代码中设置的响应头中的max-age为60，expires为Fri, 07 Sep 2013 08:05:18 GMT。这是源服务器的设置于nginx-cache的设置冲突了，那么着两个属性应该怎么设置呢？<br>这时client端的max-age与expires的值按照nginx cache中的expires配置项的设置，即:</p>
<pre><code>Expires Fri,07Sep201208:59:16GMT
Cache-Controlmax-age=30
</code></pre><p>而nginx cache端的缓存的max-age与expire的值按照源服务器上的代码的设置。即：</p>
<pre><code>Expires Fri,07Sep201308:05:18GMT
Cache-Controlmax-age=60
</code></pre><p>现在步入正题：</p>
<p>经过大量测试发现：对缓存的过期与清除起作用的因素的优先级从高到低一次为：<br>inactive配置项、源服务器设置的Expires、源服务器设置的Max-Age、proxy_cache_valid配置项<br>下面通过几个实例对这几个优先级进行说明</p>
<p>实例1：</p>
<p>服务器端php代码：</p>
<pre><code>&lt;?php
header(&quot;Expires: Fri, 07 Sep 2012 08:03:18 GMT&quot;);//其实是3分钟之后
header(&quot;Last-Modified: &quot;.gmdate(&quot;D, d M Y H:i:s&quot;).&quot; GMT&quot;);
header(&quot;Cache-Control: max-age=180&quot;);//2分钟
//header(&quot;Cache-Control: post-check=0, pre-check=0&quot;, false);
echo&quot;ta1&quot;;
?&gt;
</code></pre><p>nginx cache 配置项</p>
<p>inactive 4m//4分钟</p>
<p>proxy_cache_valid 1m//1分钟</p>
<p>现象：第一次访问页面ta1.php之后，各个时间的访问结果：</p>
<p>1分钟之后 ：HIT//这说明valid没有起作用</p>
<p>2分钟之后 ：HIT//这说明 源服务器设置的max-age没有起作用</p>
<p>3分钟之后：MISS//这说明源服务器设置的Expires起作用了</p>
<p>4分钟之后：MISS//这说明inactive起作用了</p>
<p>实例2：</p>
<p>服务器端php代码：</p>
<pre><code>&lt;?php
header(&quot;Expires: Fri, 07 Sep 2012 08:03:18 GMT&quot;);//3分钟之后
header(&quot;Last-Modified: &quot;.gmdate(&quot;D, d M Y H:i:s&quot;).&quot; GMT&quot;);
header(&quot;Cache-Control: max-age=180&quot;);//2分钟
//header(&quot;Cache-Control: post-check=0, pre-check=0&quot;, false);
echo&quot;ta1&quot;;
?&gt;
</code></pre><p>nginx cache 配置项</p>
<p>inactive 10s//10秒钟</p>
<p>proxy_cache_valid 1m//1分钟</p>
<p>现象：第一次访问页面ta1.php之后，各个时间的访问结果：</p>
<p>5秒后访问：HIT</p>
<p>10秒后访问: MISS</p>
<p>15秒后访问：HIT</p>
<p>20秒后访问:MISS</p>
<p>通过实例1和实例2综合分析：如果inactive已经进行了设置，则缓存的过期时间以inactive设置的值为准</p>
<p>实例3：</p>
<p>服务器端php代码：</p>
<pre><code>&lt;?php
header(&quot;Expires: Fri, 07 Sep 1977 08:03:18 GMT&quot;);//直接过期
header(&quot;Last-Modified: &quot;.gmdate(&quot;D, d M Y H:i:s&quot;).&quot; GMT&quot;);
header(&quot;Cache-Control: max-age=120&quot;);//2分钟
//header(&quot;Cache-Control: post-check=0, pre-check=0&quot;, false);
echo&quot;ta1&quot;;
?&gt;
</code></pre><p>nginx cache 配置项</p>
<p>inactive 4m//4分钟</p>
<p>proxy_cache_valid 1m//1分钟</p>
<p>现象：第一次访问页面ta1.php之后，各个时间的访问结果：</p>
<p>每隔一秒访问一次：MISS//这说明源服务器端设置的Expires屏蔽了nginx的valide和源服务器端设置的max-age的作用</p>
<p>实例4：</p>
<p>服务器端php代码：</p>
<pre><code>&lt;?php
header(&quot;Expires: Fri, 07 Sep 2012 08:03:18 GMT&quot;);//3分钟之后
header(&quot;Last-Modified: &quot;.gmdate(&quot;D, d M Y H:i:s&quot;).&quot; GMT&quot;);
header(&quot;Cache-Control: max-age=120&quot;);//2分钟
//header(&quot;Cache-Control: post-check=0, pre-check=0&quot;, false);
echo&quot;ta1&quot;;
?&gt;
</code></pre><p>nginx cache 配置项</p>
<p>inactive 4m//4分钟</p>
<p>proxy_cache_valid 1m//1分钟</p>
<p>现象：第一次访问页面ta1.php之后，各个时间的访问结果：</p>
<p>1分钟之后 ：   HIT//这说明valid没有起作用，因为源服务器设置的Expires将valid的效果屏蔽了</p>
<p>2分钟之后 ：   HIT//这说明 源服务器设置的max-age没有起作用，因为源服务器设置的Expires将max-age屏蔽了</p>
<p>3分钟之后：    MISS//这说明服务器端设置的expires起作用了</p>
<p>通过实例2和实例3的现象说明：如果inactive设置的比较大，在inactive到期之前，如果valid、服务器端设置的expires、服务器端设置的max-<br>age都进行了设置，则以服务器端设置的expires为准。</p>
<p>实例5：</p>
<p>服务器端php代码：</p>
<pre><code>&lt;?php
header(&quot;Expires: Fri, 07 Sep 2012 08:03:18 GMT&quot;);//3分钟之后
header(&quot;Last-Modified: &quot;.gmdate(&quot;D, d M Y H:i:s&quot;).&quot; GMT&quot;);
header(&quot;Cache-Control: max-age=120&quot;);//2分钟
//header(&quot;Cache-Control: post-check=0, pre-check=0&quot;, false);
echo&quot;ta1&quot;;
?&gt;
</code></pre><p>nginx cache 配置项</p>
<p>inactive 4m//4分钟</p>
<p>#下面两行用于消除服务器端配置的Expires响应头的影响</p>
<p>proxy_ignore_headers “Expires”;</p>
<p>proxy_hide_header “Expires”;</p>
<p>proxy_cache_valid 1m//1分钟</p>
<p>现象：第一次访问页面ta1.php之后，各个时间的访问结果：</p>
<p>1分钟之后   HIT //这说明valid的作用已经被服务器端的max-age屏蔽</p>
<p>2分钟之后   MISS//服务器端设置的max-age起作用</p>
<p>实例6：</p>
<p>服务器端php代码：</p>
<pre><code>&lt;?php
header(&quot;Expires: Fri, 07 Sep 2012 08:03:18 GMT&quot;);//3分钟之后
header(&quot;Last-Modified: &quot;.gmdate(&quot;D, d M Y H:i:s&quot;).&quot; GMT&quot;);
header(&quot;Cache-Control: max-age=50&quot;);//50秒钟
//header(&quot;Cache-Control: post-check=0, pre-check=0&quot;, false);
echo&quot;ta1&quot;;
?&gt;
</code></pre><p>nginx cache 配置项</p>
<p>inactive 4m//4分钟</p>
<p>#下面两行用于消除服务器端配置的Expires响应头的影响</p>
<p>proxy_ignore_headers “Expires”;</p>
<p>proxy_hide_header “Expires”;</p>
<p>proxy_cache_valid 2m//2分钟</p>
<p>现象：第一次访问页面ta1.php之后，各个时间的访问结果：</p>
<p>50秒钟之后 ：   MISS//这说明服务器端配置的max-age起作用</p>
<p>1分钟之后 ：   HIT//</p>
<p>100秒钟之后：   MISS//这说明服务器端设置的max-age起作用了</p>
<p>通过实例5和实例6的现象说明：如果inactive设置的比较大，而且在nginx配置文件中取消服务器端Expires对缓存的影响。在同时设置了proxy_cache_valid和服务器端设置了max-age响应头字段的情况下，以服务器端设置的max-age的值为标准进行缓存过期处理。</p>
<p>综上所述：</p>
<p>（1）在同时设置了源服务器端Expires、源服务器端max-age和nginx cahe端的proxy_cache_valid的情况下，以源服务器端设置的Expires的值为标准进行缓存的过期处理</p>
<p>（2）若在nginx中配置了相关配置项，取消原服务器端Expires对缓存的影响，在同时设置了源服务器端Expires、源服务器端max-age和nginx cahe端的proxy_cache_valid的情况下，以源服务器端max-age的值为标准进行缓存的过期处理</p>
<p>（3）若同时取消源服务器端Expires和源服务器端max-age对缓存的影响，则以proxy_cache_valid设置的值为标准进行缓存的过期处理</p>
<p>（4）Inactive的值不受上述三个因素的影响，即第一次请求页面之后，每经过inactvie指定的时间，都要强制进行相应的缓存清理。因此inactive的优先级最高。</p>
<p>（5）所以对缓存过期影响的优先级进行排序为：inactvie、源服务器端Expires、源服务器端max-age、proxy_cache_valid</p>
<p><strong>转自：<a href="http://lmdkfs.blog.163.com/blog/static/7461132420142128311980/" target="_blank" rel="external">http://lmdkfs.blog.163.com/blog/static/7461132420142128311980/</a></strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[个人博客图片测试]]></title>
      <url>http://ufdouble.com/2016/07/03/rating/</url>
      <content type="html"><![CDATA[<blockquote>
<p>图片测试</p>
</blockquote>
<h2 id="关于骑行那些事"><a href="#关于骑行那些事" class="headerlink" title="关于骑行那些事"></a>关于骑行那些事</h2><p><img src="http://i.imgur.com/bwyG01t.jpg" alt=""><br><img src="http://i.imgur.com/CorVKWU.jpg" alt=""><br><img src="http://i.imgur.com/WENVFWW.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[个人博客音乐测试]]></title>
      <url>http://ufdouble.com/2016/07/03/muisc/</url>
      <content type="html"><![CDATA[<blockquote>
<p>音乐测试</p>
</blockquote>
<h2 id="张碧晨-我可以忘记你："><a href="#张碧晨-我可以忘记你：" class="headerlink" title="张碧晨 我可以忘记你："></a>张碧晨 我可以忘记你：</h2><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=416552313&auto=1&height=66"></iframe>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[个人博客视频测试]]></title>
      <url>http://ufdouble.com/2016/07/03/video/</url>
      <content type="html"><![CDATA[<blockquote>
<p>视频测试</p>
</blockquote>
<h2 id="NBA过人集锦-脚踝终结者-Crossover："><a href="#NBA过人集锦-脚踝终结者-Crossover：" class="headerlink" title="NBA过人集锦 脚踝终结者 Crossover："></a>NBA过人集锦 脚踝终结者 Crossover：</h2><iframe height="498" width="510" src="http://player.youku.com/embed/XOTE2NTU3NTA0" frameborder="0" allowfullscreen></iframe>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[个人博客搭建详解（Windows和Mac通用版）]]></title>
      <url>http://ufdouble.com/2016/07/03/fisrtBlog/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Hexo 是一个基于nodejs 的静态博客网站生成器，作者是来自台湾的 Tommy Chen</p>
</blockquote>
<p>文／diygreen（简书作者）<br>原文链接：<a href="http://www.jianshu.com/p/380290deb8f0#" target="_blank" rel="external">http://www.jianshu.com/p/380290deb8f0#</a><br>著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。</p>
]]></content>
    </entry>
    
  
  
</search>
