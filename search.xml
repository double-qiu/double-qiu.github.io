<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[谈谈开发中的单元测试怎么写]]></title>
      <url>http://ufdouble.com/2016/07/2016/07/%E8%B0%88%E8%B0%88%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%86%99.html</url>
      <content type="html"><![CDATA[<p><strong>作者</strong>：<a href="https://github.com/double-qiu" title="DOUBLE" target="_blank" rel="external">DOUBLE</a></p>
<p><strong>时间</strong>：2016年7月6日</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>上篇博客中我谈到了<a href="http://ufdouble.com/2016/07/06/%E8%B0%88%E8%B0%88%E5%BC%80%E5%8F%91%E4%B8%AD%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/#more" title="单元测试的重要性">单元测试的重要性</a> ，并且在文章中提到过，有的人不知道怎么编写单元测试从而不去编写，在此本文介绍下如何正确的编写单元测试</p>
</blockquote>
<h2 id="编写单元测试的误区"><a href="#编写单元测试的误区" class="headerlink" title="编写单元测试的误区"></a>编写单元测试的误区</h2><p>这里其实有一个误区，很多人编写单元测试时只是一对一的去写业务测试类，例如有一个业务方法叫做保存（save），业务功能是保存一个实体到数据库中，很多人在编写单元测试的时候只添加一个测试方法叫saveTest(),然后在测试方法中封装好实体数据，调用业务方法，完成之后查看数据库是否成功保存了这条实体数据。相信很多开发人员都是这样写单元测试的，但是我在这可以很负责任的告诉各位，这种方式不是真正的单元测试。</p>
<h2 id="什么才是真正的单元测试"><a href="#什么才是真正的单元测试" class="headerlink" title="什么才是真正的单元测试"></a>什么才是真正的单元测试</h2><p>那到底什么才是真正的单元测试呢？或者怎样编写正确的单元测试呢？各位看官先别急，让我们来分析下上面提到的误区为什么不能算是单元测试，换句话说就是编写单元测试的原则</p>
<ul>
<li><strong>隔离依赖</strong></li>
</ul>
<p>在上面的举例中数据库是一个第三方的依赖，对于保存数据到数据库这个业务动作是有第三方提供的接口完成的，并不是你自己的业务逻辑，我们在编写单元测试的时候一般都会隔离它，隔离的方式一般是通过stub(数据传递输出),mock(状态行为调用)一个假的模拟来替代</p>
<ul>
<li><strong>测试覆盖</strong></li>
</ul>
<p>在上面的举例中一个业务方法对应一个测试方法这样的方式显然是不够准确的，一种数据状态能测试通过并不能保证你的业务方法就没有bug,应该有不同的数据状态去测试来保证所有的数据类型通过的情况下，这是就出现了一个概念叫做单元测试任务，如下：</p>
<p><img src="http://o9vx870vo.bkt.clouddn.com/test%20case%20%20task.jpg" alt="test case task"></p>
<h2 id="如何编程正确的单元测试"><a href="#如何编程正确的单元测试" class="headerlink" title="如何编程正确的单元测试"></a>如何编程正确的单元测试</h2><p>俗话说光说不做假把式，作为一个有节操的程序猿是不光只会纸上谈兵的，下面我们来具体编写一个实例：</p>
<p>首先你要编写单元测试肯定需要有一业务方法给你测试吧，正所谓巧妇难做无米之炊。</p>
<p><strong>模拟一个业务功能</strong>：小明（不是滚粗去的那个小明）去书店买书，付款的时候，老板通过扫描书店上的二维码来得出小明应该付多少钱！</p>
<p><strong>业务分析</strong>：这里的二维码扫描动作我们是忽然的，关键是通过二维码扫描来获取书的价格（第三方依赖），这里我们使用easyMock这个mock框架来隔离这个依赖，当然网上也有很多第三方的mock框架可以使用，常见的有easyMock和mockito等</p>
<p>maven添加junit、easyMock 依赖：</p>
<pre><code>&lt;dependencies&gt;
   &lt;dependency&gt;
     &lt;groupId&gt;junit&lt;/groupId&gt;
     &lt;artifactId&gt;junit&lt;/artifactId&gt;
     &lt;version&gt;4.12&lt;/version&gt;
     &lt;scope&gt;test&lt;/scope&gt;
   &lt;/dependency&gt;
   &lt;dependency&gt;
       &lt;groupId&gt;org.easymock&lt;/groupId&gt;
       &lt;artifactId&gt;easymock&lt;/artifactId&gt;
       &lt;version&gt;3.0&lt;/version&gt;
       &lt;scope&gt;test&lt;/scope&gt;
   &lt;/dependency&gt;
 &lt;/dependencies&gt;
</code></pre><p><strong>Book.java</strong></p>
<p>业务实体类</p>
<pre><code>package com.ufdouble.demo.testwork.model;

/**
 * ClassName: Book  
 * 书本类，name:名称  number：数量
 * @author DOUBLE
 * @version
 */
public class Book {

    private String name;
    private int number;

    public Book(String name, int number) {
        super();
        this.name = name;
        this.number = number;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getNumber() {
        return number;
    }
    public void setNumber(int number) {
        this.number = number;
    }
}
</code></pre><p>BookMarket.java<br>模拟二维码扫描书获取书本价格的业务接口</p>
<pre><code>package com.ufdouble.demo.testwork.dao;

/**
 * ClassName: BookMarket  
 * 外部接口
 * @author DOUBLE
 * @version
 */
public interface BookMarket {
    /**
     *  getPrice:获取书的价格
     *  @return_type:Double
     *  @author DOUBLE
     *  @param bookName
     *  @return
     */
    public Double getPrice(String bookName);
}
</code></pre><p>BuyBook.java</p>
<p>获取所买书总价的业务接口    </p>
<pre><code>package com.ufdouble.demo.testwork.service;
import java.util.List;
import com.ufdouble.demo.testwork.dao.BookMarket;
import com.ufdouble.demo.testwork.model.Book;

/**
 * ClassName: buyBook  
 * 业务接口
 * @author DOUBLE
 * @version
 */
public interface BuyBook {

    /**
     *  getBookTotalPrice:获取总价
     *  @return_type:double
     *  @author DOUBLE
     *  @return
     */
    public double getBookTotalPrice(List&lt;Book&gt; books,BookMarket bookMarket);

}
</code></pre><p>BuyBookImpl.java</p>
<p>书本总价的业务接口实现</p>
<pre><code>package com.ufdouble.demo.testwork.service.impl;

import java.util.List;
import com.ufdouble.demo.testwork.dao.BookMarket;
import com.ufdouble.demo.testwork.model.Book;
import com.ufdouble.demo.testwork.service.BuyBook;
/**
 * ClassName: BuyBookImpl  
 * 接口业务实现
 * @author DOUBLE
 * @version
 */
public class BuyBookImpl implements BuyBook {

    @Override
    public double getBookTotalPrice(List&lt;Book&gt; books,BookMarket bookMarket) {
        Double result = 0.0;
        if (books == null || books.size() == 0) 
            return  result;
        for (Book book : books) {
            if(book == null)  continue;
            result += (bookMarket.getPrice(book.getName()) * book.getNumber());
        }
        return result;
    }

} 
</code></pre><p>Portfolio.java</p>
<p>业务逻辑类，包括添加书本，获取所买书的总价</p>
<pre><code>package com.ufdouble.demo.testwork.business;
import java.util.ArrayList;
import java.util.List;
import com.ufdouble.demo.testwork.dao.BookMarket;
import com.ufdouble.demo.testwork.model.Book;
import com.ufdouble.demo.testwork.service.BuyBook;
import com.ufdouble.demo.testwork.service.impl.BuyBookImpl;

/**
 * ClassName: Portfolio  
 * 书单类
 * @author DOUBLE
 * @version
 */
public class Portfolio {

    private BookMarket bookMarket;
    List&lt;Book&gt; books = new ArrayList&lt;Book&gt;();

    /**
     *  getBookTotalPrice:获取总价的业务方法
     *  @return_type:String
     *  @author DOUBLE
     *  @return
     */
    public String getBookTotalPrice() {
        BuyBook buyBook = new BuyBookImpl();
        double bookTotalPrice = buyBook.getBookTotalPrice(books, bookMarket);
        return String.valueOf(bookTotalPrice);
    }
    /**
     *  setBookMarket:mock类注入
     *  @return_type:void
     *  @author DOUBLE
     *  @param bookMarket
     */
    public void setBookMarket(BookMarket bookMarket) {
        this.bookMarket = bookMarket;
    }
    /**
     *  addBook:添加书单
     *  @return_type:void
     *  @author DOUBLE
     *  @param book
     */
    public void addBook(Book book) {
        books.add(book);
    }
}
</code></pre><p>PortfolioTest.java</p>
<p>测试类</p>
<pre><code>package com.ufdouble.demo.testwork.test;
import static org.junit.Assert.*;
import org.easymock.EasyMock;
import org.junit.Before;
import org.junit.Test;
import com.ufdouble.demo.testwork.business.Portfolio;
import com.ufdouble.demo.testwork.dao.BookMarket;
import com.ufdouble.demo.testwork.model.Book;

/**
 * ClassName: PortfolioTest  
 * 业务逻辑单元测试
 * @author DOUBLE
 * @version
 */
public class PortfolioTest {

    private Portfolio portfolio;
    private BookMarket marketMock;

    @Before
    public void setUp() {
        portfolio = new Portfolio();
        marketMock = EasyMock.createMock(BookMarket.class);
        portfolio.setBookMarket(marketMock);
    }

    /**
     *  testBuyBook_OneBook_numNotZero:二本书一样的书
     *  @return_type:void
     *  @author DOUBLE
     */
    @Test
    public void testBuyBook_OneBook_numNotZero() {
        EasyMock.expect(marketMock.getPrice(&quot;JAVA&quot;)).andReturn(42.0);
        EasyMock.replay(marketMock);

        Book book = new Book(&quot;JAVA&quot;, 2);
        portfolio.addBook(book);

        assertEquals(&quot;84.0&quot;,portfolio.getBookTotalPrice());
    }
    /**
     *  testBuyBook__OneBook_numZero:数量为0的书，现实情况不可能出现，但是代码业务中可能出现
     *  @return_type:void
     *  @author DOUBLE
     */
    @Test
    public void testBuyBook__OneBook_numZero() {
        EasyMock.expect(marketMock.getPrice(&quot;JAVA&quot;)).andReturn(42.0);
        EasyMock.replay(marketMock);

        Book book = new Book(&quot;JAVA&quot;, 0);
        portfolio.addBook(book);

        assertEquals(&quot;0.0&quot;,portfolio.getBookTotalPrice());
    }
    /**
     *  testBuyBook_emptyBook:没有添加书的情况
     *  @return_type:void
     *  @author DOUBLE
     */
    @Test
    public void testBuyBook_emptyBook() {
        EasyMock.expect(marketMock.getPrice(&quot;JAVA&quot;)).andReturn(42.0);
        EasyMock.replay(marketMock);

        assertEquals(&quot;0.0&quot;,portfolio.getBookTotalPrice());
    }
    /**
     *  testBuyBook_null:添加一本为空的书的情况
     *  @return_type:void
     *  @author DOUBLE
     */
    @Test
    public void testBuyBook_null() {
        EasyMock.expect(marketMock.getPrice(&quot;JAVA&quot;)).andReturn(42.0);
        EasyMock.replay(marketMock);
        portfolio.addBook(null);
        assertEquals(&quot;0.0&quot;,portfolio.getBookTotalPrice());
    }
    /**
     *  testBuyBook_nullAndBook1:添加两种不同的书,其中有一本说为空
     *  @return_type:void
     *  @author DOUBLE
     */
    @Test
    public void testBuyBook_nullAndBook1() {
        EasyMock.expect(marketMock.getPrice(&quot;JAVA&quot;)).andReturn(42.0);
        EasyMock.replay(marketMock);
        Book book1 = new Book(&quot;JAVA&quot;, 2);
        portfolio.addBook(null);
        portfolio.addBook(book1);
        assertEquals(&quot;84.0&quot;,portfolio.getBookTotalPrice());
    }
    /**
     * 
     *  testBuyBook_diffTwoBook:添加两本不同的书
     *  @return_type:void
     *  @author DOUBLE
     */
    @Test
    public void testBuyBook_diffTwoBook() {
        EasyMock.expect(marketMock.getPrice(&quot;JAVA&quot;)).andReturn(42.0);
        EasyMock.expect(marketMock.getPrice(&quot;Spring&quot;)).andReturn(31.0);
        EasyMock.replay(marketMock);

        Book book1 = new Book(&quot;JAVA&quot;, 2);
        Book book2= new Book(&quot;Spring&quot;, 1);
        portfolio.addBook(book1);
        portfolio.addBook(book2);

        assertEquals(&quot;115.0&quot;,portfolio.getBookTotalPrice());
    }
    /**
     *  testBuyBook_diffTwoBookAndDesc:书的排序不同
     *  @return_type:void
     *  @author DOUBLE
     */
    @Test
    public void testBuyBook_diffTwoBookAndDesc() {
        EasyMock.expect(marketMock.getPrice(&quot;JAVA&quot;)).andReturn(42.0);
        EasyMock.expect(marketMock.getPrice(&quot;Spring&quot;)).andReturn(31.0);
        EasyMock.replay(marketMock);

        Book book1 = new Book(&quot;JAVA&quot;, 2);
        Book book2= new Book(&quot;Spring&quot;, 1);
        portfolio.addBook(book2);
        portfolio.addBook(book1);

        assertEquals(&quot;115.0&quot;,portfolio.getBookTotalPrice());
    }

}
</code></pre><p>正如你所看到的，在 setUp() 调用时我们创建新的 Portfolio 对象。然后我们调用 EasyMock为 BookMarket 接口创建一个模拟对象。然后我们使用 Portfolio.setBookMarket() 方法将这个对象注入到 Portfolio 对象中。</p>
<p>在 @Test方法，我们使用以下代码定义模拟对象的行为：</p>
<pre><code>EasyMock.expect(marketMock.getPrice(&quot;JAVA&quot;)).andReturn(42.0);
EasyMock.replay(marketMock);
</code></pre><p>这样一来，当 getPrice() 方法带有 “JAVA” 的参数被调用的时候，将会返回42.0。</p>
<p>然后我们创建了一个数量为2的 javaBook ，并将其添加到我们的 Portfolio 中。将我们设置 JAVA 价格定为 42.0 时，我们便知道书本的总价格为 84.00（2*42.00）。在最后一行，我们使用assertEquals() 进行了同样的声明。</p>
<p>如果 getBookTotalPrice() 中代码不出错的话，以上测试应该会成功，否则测试将会失败。</p>
<p><strong>结论</strong></p>
<p>以上便是如果使用 EasyMock 库模拟外部服务/对象以及在测试代码中使用的示例，EasyMock 能做的远不止我在上面展示的，可以去网上搜索更多有关mock框架的信息</p>
<p>本文的测试代码在我的gitHub库中，感兴趣的朋友可以clone下来参考下 <a href="https://github.com/double-qiu/DemoWork" title="DemoWork" target="_blank" rel="external">DemoWork</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[谈谈开发中单元测试的重要性]]></title>
      <url>http://ufdouble.com/2016/07/2016/07/%E8%B0%88%E8%B0%88%E5%BC%80%E5%8F%91%E4%B8%AD%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7.html</url>
      <content type="html"><![CDATA[<p><strong>作者</strong>：<a href="https://github.com/double-qiu" title="DOUBLE" target="_blank" rel="external">DOUBLE</a></p>
<p><strong>时间</strong>：2016年7月6日</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>最近，在网上看到过一个调查，调查的内容是“程序员在项目开发中编写单元测试的情况”。当然，至于调查的结果，我想聪明的你已经可以猜到了。高达 58.3% 的比例，一般情况下不写单元测试，只有偶尔的情况才会写写。16.6% 的程序员从来都不写单元测试。只有很少的一部分程序员才会在自己的代码中进行单元测试，并保证方法测试通过。看到这些，你想到了什么？</p>
</blockquote>
<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>虽然，这个调查可能会有些片面性，但这也基本反应了国内程序员的开发现状，很少有程序员能够比较认真的去编写单元测试。而且，甚至有的程序员根本就不知道为什么要写单元测试（这一点让我很郁闷）。他们经常会说，公司里不是有测试人员嘛，测试应该是他们要做的事，我们的工作只是开发（这位仁兄肯定没有学过软件工程）。当然，这些并不是偶然的，正如佛经里边说的“因果循环”，有果必有因。那么，到底是什么原因，导致程序员对单元测试这么不感冒呢？</p>
<h2 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h2><p>通过与几个朋友的讨论，以及网上的调查，主要有这几种原因，导致程序员对单元测试很排斥，或许说很不以为意。</p>
<ul>
<li>不知道怎么编写单元测试</li>
<li>项目没有要求，所以不编写</li>
<li>单元测试价值不高，完全是浪费时间</li>
<li>业务逻辑比较简单，不值得编写单元测试</li>
<li>不管怎样，集成测试将会抓住所有的 bug，用不着进行单元测试</li>
<li>在项目的前期还是尽量去编写单元测试，但是越到项目的后期就越失控</li>
<li>为了完成编码任务，没有足够的时间编写单元测试。编写单元测试会导致不能按时完成编码任务，导致项目延期</li>
</ul>
<p>很显然，这几种原因归根结底，无外乎就是不了解单元测试，自认为很聪明，自己懒不想去测试，对项目的时间、进度把控不好。下面，我将一 一进行分析，剖析出程序员的开发心理，以此来给朋友们提个醒，最终聪明反被聪明误。</p>
<h2 id="剖析"><a href="#剖析" class="headerlink" title="剖析"></a>剖析</h2><p><strong>不知道怎么编写单元测试</strong></p>
<p>这个问题在于，还没有接触过单元测试，同时，也没有体会过企业级的代码开发。不知道同时也不了解单元测试能带给你什么。设想一下，当你开发完一个功能模块的时候，你如何确定你的模块没有 bug 呢？如果涉及到具体的业务，你会执行 debug 模式，然后一点一点的深入到代码中去查看吗？如果你一直都是这样，那么你早就已经 OUT 了。赶快去了解一下单元测试的工具吧，你会收获很大的。</p>
<p><strong>项目没有要求，所以不编写</strong></p>
<p>这个问题反映出了一种现象，同时也是一种习惯。项目有没有要求，只能说明项目的管理上不严格，并不是程序员不编写单元测试的理由。他们在以往的开发中，并没有养成写单元测试的好习惯。可想而知，他们的代码质量，我就不敢恭维了。给个建议，尝试着写漂亮的代码，之所以因为漂亮，是指得健康、简洁、健壮。当然，完成漂亮的代码就离不开单元测试了。</p>
<p><strong>单元测试价值不高，完全是浪费时间</strong></p>
<p>这种说法其实是错误的。为什么这么说呢？在日常的开发中，代码的完工其实并不等于开发的完工。如果没有单元测试，那么如何保证代码能够正常运行呢？测试人员做的只是业务上的集成测试，也就是黑盒测试，对单个的方法是没有办法测试的，而且，测试出的 bug 的范围也会很广，根本不能确定 bug 的范围，还得去花时间来确定 bug 出在什么地方。难道这就不浪费时间了吗？甚至，这样的方式，时间浪费的会更多。</p>
<p><strong>业务逻辑比较简单，不值得编写单元测试</strong></p>
<p>所谓的业务逻辑比较简单，其实是相对的。当你对某一块业务逻辑很熟悉的时候，你自然会认为它很简单。然而，单元测试的必要性并不是仅仅在于测试代码的功能是否正确，还在于，当其他同事在了解你的业务的时候，能够很快的通过单元测试来熟悉代码的功能，甚至不用去读代码，就能够知道它做了哪些事情。因此，写单元测试不仅是解放了自己，更方便了别人。</p>
<p><strong>项目前期还在尽量写测试，到了后期就失控了</strong></p>
<p>这种问题的原因在于，对项目进度、项目中的技术点研究时间、人员的沟通、业务需求的熟悉程度等没有把控好。这个问题的出现并不是个人的问题，而是反映了项目管理中存在的问题。当然，个人的原因也存在，就是如何在有限的时间里，提高效率。这一点需要大家好好思考一下了。我的建议，多做计划，根据实际情况变更计划。多和项目组长、组成员进行沟通。及时反应项目中存在的问题。</p>
<p><strong>为了完成编码任务，没有足够的时间编写单元测试</strong></p>
<p>这个问题在于，程序员领取的任务较为复杂，或者自己的开发效率有待提高。其实，开发任务是包括编码和单元测试的。在领任务的时候，应该跟据自身的能力，跟组长或经理沟通好，以便留出一定的测试时间。当然，提高自己的编码效率也是很有必要的。至于如何提高开发效率，网上有很多这样的文章，这里就不再赘述了。</p>
<h2 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h2><p>测试常常是程序员十分厌倦的一个活动。测试能给我们带来什么？了解这些是非常重要的，测试不可能保证一个程序是完全正确的，但是测试却可以增强我们对程序完整的信心，测试可以让我们相信程序做了我么期望它做的事情。测试能够使我们尽早的发现程序的 bug 和不足。</p>
<p>一个 bug 被隐藏的时间越长，修复这个 bug 的代价就越大。在《快速软件开发》一书中已引用了大量的研究数据指出：最后才修改一个 bug 的代价是在 bug 产生时修改它的代价的10倍。</p>
<p>当然，我们主要讨论的是单元测试。单元测试是一个方法层面上的测试，也是最细粒度的测试。用于测试一个类的每一个方法都已经满足了方法的功能要求。在开发中，对于自己开发的模块，只有在通过单元测试之后，才能提交到 SVN 库 或者 Git 库。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>正是由于测试在开发中的重要地位，才会在IT界刮起了 TDD 的旋风。TDD，也就是测试驱动开发模式。它旨在强调在开发功能代码之前，先编写测试代码。也就是说在明确要开发某个功能后，首先思考如何对这个功能进行测试，并完成测试代码的编写，然后编写相关的代码满足这些测试用例。然后循环进行添加其他功能，直到完成全部功能的开发。</p>
<p><strong>注：</strong> 关于测试驱动开发，我之前的博客中有提到过，请参考之前的博文《<a href="http://ufdouble.com/2016/07/04/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91TDD/" title="测试驱动开发">测试驱动开发</a>》</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>说了这么多，那么都有什么工具（框架）能帮助我们完成可重复的单元测试呢？下面我就介绍几个常用的。这里只介绍 Java 语言的。其他语言的请问谷老师（Google）。</p>
<ul>
<li>JUnit（推荐使用JUnit4）</li>
</ul>
<p>JUnit 在日常开发中还是很常用的，而且 Java 的各种 IDE （Eclipse、MyEclipse、IntelliJ IDEA）都集成了 JUnit 的组件。当然，自己添加插件也是很方便的。JUnit 框架是 Java 语言单元测试当前的一站式解决方案。这个框架值得称赞，因为它把测试驱动的开发思想介绍给 Java 开发人员并教给他们如何有效地编写单元测试。</p>
<ul>
<li>TestNG</li>
</ul>
<p>TestNG，即Testing Next Generation，下一代测试技术。是根据JUnit和NUnit思想，采用 jdk 的 annotation 技术来强化测试功能并借助XML 文件强化测试组织结构而构建的测试框架。TestNG 的强大之处还在于不仅可以用来做单元测试，还可以用来做集成测试。</p>
<p>这里仅仅是介绍一下有哪些最常用的 Java 单元测试工具，对于如何使用这些工具，在后续的博客中会有介绍，这里就不再多说了。有兴趣的请关注后续的文章。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>俗话说，一屋不扫，何以扫天下。开发中，我们自己的代码都不能保证功能的正确性，那么还有什么效率可言呢？做再多的任务，写再多的代码也只不过是在搭鸡窝，做着机器一样的重复的工作。IT界有一个原则，DRY原则 —— Don’t Repeat Yourself ！只有通过对自己的工作不断的检查，不断的测试，才能不断的突破，不断的脱颖而出，当然，你才能不断的提高。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何成为一名优秀的全栈工程师？]]></title>
      <url>http://ufdouble.com/2016/07/2016/07/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E4%BC%98%E7%A7%80%E7%9A%84%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88.html</url>
      <content type="html"><![CDATA[<p><img src="http://i.imgur.com/JO6Qoaf.jpg" alt=""></p>
<p><strong>作者</strong>：<a href="https://github.com/double-qiu" title="DOUBLE" target="_blank" rel="external">DOUBLE</a></p>
<p><strong>时间</strong>：2016年7月5日</p>
<blockquote>
<p>谈谈如何才能成为一名优秀的全栈工程师。</p>
</blockquote>
<h2 id="什么是全栈工程师"><a href="#什么是全栈工程师" class="headerlink" title="什么是全栈工程师"></a>什么是全栈工程师</h2><p>全栈工程师一词，最早出现于Facebook工程师Calos Bueno的一篇文章 – Full Stack（需翻墙）。他把全栈工程师定义为对性能影响有着深入理解的技术通才。自那以后全栈这个词便流行起来，我看到过的就有全栈工程师，全栈设计师，全栈运维，全栈市场营销人员等等。而在针对互联网人才的招聘网站上，全栈工程师更是一跃成为热门招聘职位，其薪资水平也比一般的开发工程师职位要高出一截。那么，什么是全栈工程师，我们又应该如何定义一名全栈工程师呢？</p>
<p>百度百科对全栈工程师的定义是这样的：“掌握多种技能，并能利用多种技能独立完成产品的人”。我觉得这个定义还不够全面，我认为全栈工程师应该同时是一位资深开发工程师、架构师以及具有敏捷开发技能的程序员。全栈工程师对于软件开发的认识往往已经进化了，他们把特定的技术抛到了身后，明白技术的更新始终比计算机理论要快的道理，因此，他们注重强化自身的核心技能，关注并乐于实践其他技术。全栈工程师往往是某一方面的专家，同时通晓并善于在正确的场合运用其他语言、工具和技术。</p>
<h2 id="全栈工程师的价值"><a href="#全栈工程师的价值" class="headerlink" title="全栈工程师的价值"></a>全栈工程师的价值</h2><p>随着时间的推移，全栈工程师的作用和价值在越来越多的产品或项目中得到了印证。那么，我们来看看全栈工程师对于个人或公司意味着什么。</p>
<ul>
<li><p><strong>个人价值及自由度的极大提升</strong> —— 我曾看过一些介绍全栈工程师的文章，文中大多强调了全栈工程师对于公司与团队的价值。而我想说的是，没有一个优秀的全栈工程师是因为会对公司产生多大的利益，而努力学习各种技术的。我所认识的他们，都是那些有着一颗匠心，不断追求更高技能，并执着于做出更优秀产品的人。而当你成为一名真正的全栈工程师后，会感受到前所未有的个人价值与技术自由度的提升。试想当一个很好的创意出现时，你可以一个人或主导一个团队去实现并不断完善它，这是一件多么让人兴奋的事啊！</p>
</li>
<li><p><strong>全局思维与技术前瞻性</strong> —— 由于具备了各个开发环节与技术领域的知识，全栈工程师往往具有更好的大局观和技术前瞻性，能够在项目初期就选择正确的技术，并很好地把控一个项目的整体方向。现代项目往往非常复杂，而全栈工程师往往能带来技术和质量上的保障，从而成为一个项目成功的关键人物。</p>
</li>
<li><p><strong>降低沟通成本</strong> —— 我经常听到有设计师抱怨前端工程师无法百分之百地还原他们的设计，而前端工程师又在抱怨后端工程师从接口返回的数据更本无法直接使用，后端工程师也在抱怨产品经理所提的需求根本无法完成。随着团队人数的上升，由于各自技能栈的不同，沟通成本一定会随之上升。全栈工程师除了能够独立完成前后端的开发（甚至包括设计）外，如果能够在项目初期提前介入，便能很好地规避技术风险，过滤不合理的需求，从而显著降低因不同技术差异导致的沟通问题，显著降低项目风险。</p>
</li>
<li><p><strong>初创公司</strong> —— 我们已经来到了一个万众创业，全民创新的时代。那些初创公司也如雨后春笋般不断涌现。初创公司往往都有了一个不错的创意，但经常会遇到“就缺一个程序员”的尴尬。我想说的是，他们其实并不是缺程序员，而是缺一位全栈工程师。初创公司往往资金有限，而一名优秀的全栈工程师能够帮助初创公司用最低的代价与最短的时间推出自己的产品。这是初创公司能够存活下来，拿到更多投资，甚至成为“独角兽”一员的最关键一步。</p>
</li>
</ul>
<h2 id="全栈工程师的技能栈"><a href="#全栈工程师的技能栈" class="headerlink" title="全栈工程师的技能栈"></a>全栈工程师的技能栈</h2><p>看到这里你一定会问，到底需要具备怎样的技能才能成为一名全栈工程呢？下面这张图来自Medium，作者将软件开发所涉及的各个方面分为层，又将每个层所包含的主要技术作为组件，制作了这张全栈技术图。<br><img src="http://i.imgur.com/jhCGREb.jpg" alt=""></p>
<p>从上面这张图，我们不难发现，现在的技术体系是多么庞大，每一年又会有新的技术加入到这些层中，而已有的技术又在不断地更新。因此要掌握所有技术是根本不可能的，而成为全栈工程师也并不需要你真的掌握所有的技术，你应该将自己的精力聚焦于关键开发技能以及一些必须掌握的附加技能上。</p>
<h2 id="关键开发技能（硬实力）："><a href="#关键开发技能（硬实力）：" class="headerlink" title="关键开发技能（硬实力）："></a>关键开发技能（硬实力）：</h2><ul>
<li><p><strong>Git / GitHub</strong> —— 你必须掌握如何使用Git来管理和分享你的代码。把Git作为关键技能的第一条，是因为它不仅仅是一个代码管理工具，更是一种推荐的工作方式。它使你能在任何地方进行开发，高效地管理任何大小的项目，通过Git你还能与其他团队成员进行分布式协作，大大提升工作效率。通过GitHub，还能将你与世界所有的开发者联系在一起。</p>
</li>
<li><p><strong>至少一门编程语言</strong> —— 你需要精通至少一门编程语言，JAVA 、PHP、C#、Python、Ruby、Perl 等，因为你的大多数核心业务处理都需要用这门语言来写。你既要掌握这门语言的语法，又需要非常熟悉如何基于这门语言进行项目的架构、设计、实现以及测试。如果你选择的是JAVA，那么你就需要掌握面向对象的设计和开发，设计模式的应用，基于J2EE各个组件的开发 等等。</p>
</li>
<li><p><strong>运用开发框架和第三方库</strong> —— 流行的开发语言，一般都伴有出色的开发框架，比如JAVA的Spring、MyBatis、Hibernate，Python的Django，PHP的 thinkphp、yin，nodeJs的 express 等等。这些开发框架往往都遵循软件开发领域的一些最佳实践，并由非常优秀的开发人员创建。熟练使用这些开发框架或第三方库能够避免重复发明轮子，使你的工作事半功倍。更重要的是这些优秀框架或第三方库的一般都得到持续的维护，是对你的产品或项目在质量与安全方便的最有效的保障。<br>前端技术 —— 之所以将前端技术独立出来，作为一项关键技术，是因为它在今天的项目和产品的研发过程中正变得越来越重要。一个产品除了实现所需的功能之外，是否好用（用户体验）也正在成为评判一个产品是否成功的重要标准。而这都依赖于前端技术的实现，你至少需要掌握 HTML5、CSS3、JavaScript 等基本前端技术，同时进一步学习 JQuery、LESS、SASS、AngularJS或REACT等前端框架或第三方库。</p>
</li>
<li><p><strong>数据库与缓存</strong> —— 任何产品或项目都需要一个数据库来存储数据。作为全栈工程师，你也需要至少掌握一到两个数据库，并知道怎样与数据库进行交互。目前流行的数据库主要有MySQL、MongoDB、Redis、Oracle、SQLServer等。MongoDB作为文档型数据库，在互联网产品中正被越来越多地使用，对于规模稍大一些的项目，我仍推荐使用MySQL或商用的Oracle作为后端数据库。而Redis这样的内存数据库则可以用于缓存，以提升系统的性能。</p>
</li>
<li><p><strong>基本设计能力</strong> —— 大部分关于全栈工程师的文章或讨论中，都不会将设计能力做为全栈工程师的关键技能，但我却认为这项技能非常重要。我曾被邀请评估一些软件工程师自己开发的产品，这些产品都有不错的创意，功能实现也很到位，但一看就不是一个好的产品，用户根本没有使用欲望，原因是这些产品的设计太差了，而往往那些开发者完全没有意识到问题的存在，比如色彩的不一致，排版的凌乱，不恰当的图标 等等。我所建议的基本设计能力，并不要求你像专业设计师那样能够P出神图、制作奇妙的视觉效果等，但你需要掌握最基本的UI设计原则，如 色彩的搭配，基本的排版，并具备良好的审美能力，和一些基本UI设计能力，这样你做的产品就不会太差了。</p>
</li>
</ul>
<p>在掌握了这些核心技能之后，你可以根据自己的兴趣与发展方向，学习其他方面的技术。比如，如果你对数据处理感兴趣，那么你可以学习大数据方面的技术。如果你对移动互联网更感兴趣，那么你可以学习Swift，开发ios应用。知识总是相通的，在有了良好的技术基础后，学习其他知识将会变得非常容易。</p>
<h2 id="附加技能（软实力）："><a href="#附加技能（软实力）：" class="headerlink" title="附加技能（软实力）："></a>附加技能（软实力）：</h2><ul>
<li><strong>沟通</strong> —— 除非你是在做个人项目，对于稍大一些的项目，你总是需要与同事、干系人或是客户进行沟通的。而成功的沟通往往是获得有效需求，与建立团队信心的第一步。在项目的进行过程中，你更需要通过有效的沟通去确定方案，消除误解，与项目成员协同前进。良好的沟通能力将使你在团队中更具影响力，收到更多尊重和关注。</li>
</ul>
<ul>
<li><p>问题解决能力 —— 全栈工程师首先是一名工程师，他必须掌握工程化的方法来解决遇到的各种问题。我在职业生涯中的几乎所有亮点，都与解决问题相关，大到提供整个项目的架构方案，小到以最快的速度解决生产问题 等。其实有很多提高问题解决能力的方法，但没有一种比实践更有效。我所见到的优秀工程师，往往能够凭借直觉以最短的时间给出正确的解决方案，但你可能没有看到的是，在这背后其实是经过大量实践累积而来的经验。</p>
</li>
<li><p><strong>时间管理</strong> —— 作为全栈工程师，你可能会被安排同时在不同的项目中承担不同的角色。你需要合理地分配时间，保证所有的工作能够按时交付。同样在你的业余时间，你还需要花时间阅读和学习，同时你还可能会有自己的Side Project。因此，合理地进行时间分配，并对一些关键任务，进行计划是很重要的。你或许会感到一些压力，但这反而会激发你的创造力，并能让一切都有条不紊地进行。</p>
</li>
<li><p><strong>好奇心</strong> —— 对任何工作都抱有好奇心，并愿意不断学习和改善是那些优秀工程师的共同特性。软件开发领域汇集了世界上最聪明的人，各种类型的技术、产品、框架更是日新月异，层出不穷。优秀的全栈工程师需要不断地学习来抓住这些变化，跟上计算机领域发展的脚步。时常有人会问我，做计算机这一行一直会有新的东西产生，要去不断地学习，是不是会很累。我要说的是，对于将持续学习作为一种生活习惯的人来说，学习新东西并不会成为一种负担，反而是一种乐趣。</p>
</li>
<li><p><strong>领导力</strong> —— 优秀的全栈工程师往往会被赋予技术Leader甚至项目管理者的角色。成为管理者并不是让你去支配其他人，或让其他人替你做事。管理者需要理解你的团队成员的长处与不足，并知道如何以服务的态度使团队获得最大化的产出。我见过一些非常优秀的工程师，当他们被安排去管理团队时，他们是排斥的，他们往往更愿意独自工作。但我想说，成为管理者，将会使你更加睿智、可靠和值得他人信赖，也会对你未来的职业生涯带来极大的益处。因此，当机会到来时，请将它视为挑战，不要排斥它。</p>
</li>
</ul>
<p>有经验的技术领导者在招聘时，往往会同时考察应聘者技术能力与上述附加技能，而对于初级程序员的招聘来说，那些附加技能往往更被优秀的技术公司所看重。开发技能是你的硬实力，而附加技能则可以看作是你的软实力，只有同时具备这两方面技能，才能成为一名优秀的全栈工程师。</p>
<h2 id="优秀的全栈工程师需要走出去"><a href="#优秀的全栈工程师需要走出去" class="headerlink" title="优秀的全栈工程师需要走出去"></a>优秀的全栈工程师需要走出去</h2><p>优秀的全栈工程师不应局限于自己的工作，他更应该走出去，接触不同的技术，分享自己的经验和心得，认识更多的朋友。下面便是我的一些做法。</p>
<ul>
<li><strong>参加技术大会</strong> —— InfoQ、CSDN、GITC、优设、TED 等网站都会定期举办各类技术大会。在这些大会上，你不仅能够听到技术大咖们带来的各自领域最佳技术实践，而且能认识很多行业内的朋友。这对你开拓思路，扩大技术社交圈都很有帮助。因此，如果公司没有安排你去参加这些技术大会的话，那就自己买票参加，作为对自己的一种投资吧。</li>
</ul>
<ul>
<li><p><strong>作公开演讲</strong> —— 全栈工程师并不需要是一个公开演讲者，但作为团队的核心成员，他一定需要在团队内部做技术、管理等方面的进行演讲。如果你是一个乐于分享的技术达人，那么也可以尝试录制个人课程（视频或音频），并在慕课、网易课堂、优酷 或 像 荔枝、喜马拉雅 等各种媒体分享自己的技能和知识，不要因为自己并不是专家就不愿尝试，相信我，你用心制作的内容，会获得大家的认可，并收获一大批粉丝的。</p>
</li>
<li><p><strong>个人博客</strong> —— 每天进步一点点，一年以后你便会获得质的飞跃。优秀的全栈工程师懂得如何进行知识的积累，而技术博客就是一个很好的方式，将自己平时的实践、思考记录下来，配以tag标签方便日后的回顾。最有意思的是，当你在不断记录和更新你的博客同时，世界各地的程序员也会通过你的博客认识你。</p>
</li>
<li><p><strong>参加线下活动</strong> —— 与以前程序员总是宅在家里不同，现在的年轻程序员们更愿意分享和交流。很多网站也会组织不同技术主题的线下活动，在这些活动中你可以听到一些技术牛人的分享，还可以找到很多和你一样对技术富有激情的人。而我现在所做的开源项目中的很多团队成员，正是我在这些线下活动中结识的。</p>
</li>
</ul>
<p>全栈工程师决不是一夜练成的，你需要打好技术基础，强化核心技能，并持续学习。感受到自由地运用技术，开发出优秀产品所带来的乐趣的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[敏捷开发]]></title>
      <url>http://ufdouble.com/2016/07/2016/07/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91.html</url>
      <content type="html"><![CDATA[<p><strong>作者</strong>：<a href="https://github.com/double-qiu" title="DOUBLE" target="_blank" rel="external">DOUBLE</a></p>
<p><strong>时间</strong>：2016年7月4日</p>
<blockquote>
<p>现在敏捷开发是越来越火了，人人都在谈敏捷，人人都在学习Scrum和XP…<br>为了不落后他人，于是我也开始学习Scrum，今天主要是对我最近阅读的相关资料，根据自己的理解，用自己的话来讲述Scrum中的各个环节，主要目的有两个，一个是进行知识的总结，另外一个是觉得网上很多学习资料的讲述方式让初学者不太容易理解；所以我决定写一篇扫盲性的博文，同时试着也与园内的朋友一起分享交流一下，希望对初学者有帮助。</p>
</blockquote>
<h2 id="什么是敏捷开发？"><a href="#什么是敏捷开发？" class="headerlink" title="什么是敏捷开发？"></a>什么是敏捷开发？</h2><p>敏捷开发(Agile Development)是一种以人为核心、迭代、循序渐进的开发方法。<br>怎么理解呢？首先，我们要理解它不是一门技术，它是一种开发方法，也就是一种软件开发的流程，它会指导我们用规定的环节去一步一步完成项目的开发；而这种开发方式的主要驱动核心是人；它采用的是迭代式开发；</p>
<h2 id="为什么说是以人为核心？"><a href="#为什么说是以人为核心？" class="headerlink" title="为什么说是以人为核心？"></a>为什么说是以人为核心？</h2><p>我们大部分人都学过瀑布开发模型，它是以文档为驱动的，为什么呢？因为在瀑布的整个开发过程中，要写大量的文档，把需求文档写出来后，开发人员都是根据文档进行开发的，一切以文档为依据；而敏捷开发它只写有必要的文档，或尽量少写文档，敏捷开发注重的是人与人之间，面对面的交流，所以它强调以人为核心。</p>
<h2 id="什么是迭代？"><a href="#什么是迭代？" class="headerlink" title="什么是迭代？"></a>什么是迭代？</h2><p>迭代是指把一个复杂且开发周期很长的开发任务，分解为很多小周期可完成的任务，这样的一个周期就是一次迭代的过程；同时每一次迭代都可以生产或开发出一个可以交付的软件产品。</p>
<h2 id="关于Scrum和XP"><a href="#关于Scrum和XP" class="headerlink" title="关于Scrum和XP"></a>关于Scrum和XP</h2><p>前面说了敏捷它是一种指导思想或开发方式，但是它没有明确告诉我们到底采用什么样的流程进行开发，而Scrum和XP就是敏捷开发的具体方式了，你可以采用Scrum方式也可以采用XP方式；Scrum和XP的区别是，Scrum偏重于过程，XP则偏重于实践，但是实际中，两者是结合一起应用的，这里我主要讲Scrum。</p>
<h2 id="什么是Scrum？"><a href="#什么是Scrum？" class="headerlink" title="什么是Scrum？"></a>什么是Scrum？</h2><p>Scrum的英文意思是橄榄球运动的一个专业术语，表示“争球”的动作；把一个开发流程的名字取名为Scrum，我想你一定能想象出你的开发团队在开发一个项目时，大家像打橄榄球一样迅速、富有战斗激情、人人你争我抢地完成它，你一定会感到非常兴奋的。<br>而Scrum就是这样的一个开发流程，运用该流程，你就能看到你团队高效的工作。</p>
<h2 id="【Scrum开发流程中的三大角色】"><a href="#【Scrum开发流程中的三大角色】" class="headerlink" title="【Scrum开发流程中的三大角色】"></a>【Scrum开发流程中的三大角色】</h2><h3 id="产品负责人（Product-Owner）"><a href="#产品负责人（Product-Owner）" class="headerlink" title="产品负责人（Product Owner）"></a>产品负责人（Product Owner）</h3><p>主要负责确定产品的功能和达到要求的标准，指定软件的发布日期和交付的内容，同时有权力接受或拒绝开发团队的工作成果。</p>
<h3 id="流程管理员（Scrum-Master）"><a href="#流程管理员（Scrum-Master）" class="headerlink" title="流程管理员（Scrum Master）"></a>流程管理员（Scrum Master）</h3><p>主要负责整个Scrum流程在项目中的顺利实施和进行，以及清除挡在客户和开发工作之间的沟通障碍，使得客户可以直接驱动开发。</p>
<h3 id="开发团队（Scrum-Team）"><a href="#开发团队（Scrum-Team）" class="headerlink" title="开发团队（Scrum Team）"></a>开发团队（Scrum Team）</h3><p>主要负责软件产品在Scrum规定流程下进行开发工作，人数控制在5~10人左右，每个成员可能负责不同的技术方面，但要求每成员必须要有很强的自我管理能力，同时具有一定的表达能力；成员可以采用任何工作方式，只要能达到Sprint的目标。</p>
<p><strong>Scrum流程图</strong><br><img src="http://i.imgur.com/LRdmK1w.jpg" alt=""></p>
<p>下面，我们开始讲具体实施流程，但是在讲之前，我还要对一个英文单词进行讲解。</p>
<h2 id="什么是Sprint？"><a href="#什么是Sprint？" class="headerlink" title="什么是Sprint？"></a>什么是Sprint？</h2><p>Sprint是短距离赛跑的意思，这里面指的是一次迭代，而一次迭代的周期是1个月时间（即4个星期），也就是我们要把一次迭代的开发内容以最快的速度完成它，这个过程我们称它为Sprint。</p>
<h2 id="如何进行Scrum开发？"><a href="#如何进行Scrum开发？" class="headerlink" title="如何进行Scrum开发？"></a>如何进行Scrum开发？</h2><ol>
<li><p>我们首先需要确定一个Product Backlog（按优先顺序排列的一个产品需求列表），这个是由Product Owner 负责的；</p>
</li>
<li><p>Scrum Team根据Product Backlog列表，做工作量的预估和安排；</p>
</li>
<li><p>有了Product Backlog列表，我们需要通过 Sprint Planning Meeting（Sprint计划会议） 来从中挑选出一个Story作为本次迭代完成的目标，这个目标的时间周期是1~4个星期，然后把这个Story进行细化，形成一个Sprint Backlog；</p>
</li>
<li><p>Sprint Backlog是由Scrum Team去完成的，每个成员根据Sprint Backlog再细化成更小的任务（细到每个任务的工作量在2天内能完成）</p>
</li>
<li><p>在Scrum Team完成计划会议上选出的Sprint Backlog过程中，需要进行 Daily Scrum Meeting（每日站立会议），每次会议控制在15分钟左右，每个人都必须发言，并且要向所有成员当面汇报你昨天完成了什么，并且向所有成员承诺你今天要完成什么，同时遇到不能解决的问题也可以提出，每个人回答完成后，要走到黑板前更新自己的 Sprint burn down（Sprint燃尽图）；</p>
</li>
<li><p>做到每日集成，也就是每天都要有一个可以成功编译、并且可以演示的版本；很多人可能还没有用过自动化的每日集成，其实TFS就有这个功能，它可以支持每次有成员进行签入操作的时候，在服务器上自动获取最新版本，然后在服务器中编译，如果通过则马上再执行单元测试代码，如果也全部通过，则将该版本发布，这时一次正式的签入操作才保存到TFS中，中间有任何失败，都会用邮件通知项目管理人员；</p>
</li>
<li><p>当一个Story完成，也就是Sprint Backlog被完成，也就表示一次Sprint完成，这时，我们要进行 Srpint Review Meeting（演示会议），也称为评审会议，产品负责人和客户都要参加（最好本公司老板也参加），每一个Scrum Team的成员都要向他们演示自己完成的软件产品（这个会议非常重要，一定不能取消）；</p>
</li>
<li><p>最后就是 Sprint Retrospective Meeting（回顾会议），也称为总结会议，以轮流发言方式进行，每个人都要发言，总结并讨论改进的地方，放入下一轮Sprint的产品需求中；</p>
</li>
</ol>
<p><strong>下面是运用Scrum开发流程中的一些场景图：</strong><br><img src="http://i.imgur.com/3462EkG.png" alt=""></p>
<p>上图是一个 Product Backlog 的示例。</p>
<p><img src="http://i.imgur.com/o2KWOy1.png" alt=""></p>
<p>上图就是每日的站立会议了，参会人员可以随意姿势站立，任务看板要保证让每个人看到，当每个人发言完后，要走到任务版前更新自己的燃尽图。</p>
<p><img src="http://i.imgur.com/PDe0XDO.png" alt=""></p>
<p>任务看版包含 未完成、正在做、已完成 的工作状态，假设你今天把一个未完成的工作已经完成，那么你要把小卡片从未完成区域贴到已完成区域。</p>
<p><img src="http://i.imgur.com/iaCmWmj.png" alt=""></p>
<p>每个人的工作进度和完成情况都是公开的，如果有一个人的工作任务在某一个位置放了好几天，大家都能发现他的工作进度出现了什么问题（成员人数最好是5~7个，这样每人可以使用一种专用颜色的标签纸，一眼就可以从任务版看出谁的工作进度快，谁的工作进度慢）</p>
<p><img src="http://i.imgur.com/nFVvNbr.png" alt=""></p>
<p>上图可不是扑克牌，它是计划纸牌，它的作用是防止项目在开发过程中，被某些人所领导。</p>
<p>怎么用的呢？比如A程序员开发一个功能，需要5个小时，B程序员认为只需要半小时，那他们各自取相应的牌，藏在手中，最后摊牌，如果时间差距很大，那么A和B就可以讨论A为什么要5个小时…</p>
<p><strong>敏捷开发的4句宣言</strong></p>
<p>个体与交互 胜过 过程与工具</p>
<p>可以工作的软件 胜过 面面俱到的文挡</p>
<p>客户协作 胜过 合同谈判</p>
<p>响应变化 胜过 遵循计划</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[测试驱动开发（TDD）]]></title>
      <url>http://ufdouble.com/2016/07/2016/07/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91TDD.html</url>
      <content type="html"><![CDATA[<p><strong>作者</strong>：<a href="https://github.com/double-qiu" title="DOUBLE" target="_blank" rel="external">DOUBLE</a></p>
<p><strong>时间</strong>：2016年7月4日</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote>
<p>一个高效的软件开发过程对软件开发人员来说是至关重要的，决定着开发是痛苦的挣扎，还是不断进步的喜悦。国人对软件蓝领的不屑，对繁琐冗长的传统开发过程的不耐，使大多数开发人员无所适从。最近兴起的一些软件开发过程相关的技术，提供一些比较高效、实用的软件过程开发方法。其中比较基础、关键的一个技术就是测试驱动开发（Test-Driven Development）。虽然TDD光大于极限编程，但测试驱动开发完全可以单独应用。下面就从开发人员使用的角度进行介绍，使开发人员用最少的代价尽快理解、掌握、应用这种技术。下面分优势，原理，过程，原则，测试技术，Tips等方面进行讨论</p>
</blockquote>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>TDD的基本思路就是通过测试来推动整个开发的进行。而测试驱动开发技术并不只是单纯的测试工作。</p>
<p>需求向来就是软件开发过程中感觉最不好明确描述、易变的东西。这里说的需求不只是指用户的需求，还包括对代码的使用需求。很多开发人员最害怕的就是后期还要修改某个类或者函数的接口进行修改或者扩展，为什么会发生这样的事情就是因为这部分代码的使用需求没有很好的描述。测试驱动开发就是通过编写测试用例，先考虑代码的使用需求（包括功能、过程、接口等），而且这个描述是无二义的，可执行验证的。</p>
<p>通过编写这部分代码的测试用例，对其功能的分解、使用过程、接口都进行了设计。而且这种从使用角度对代码的设计通常更符合后期开发的需求。可测试的要求，对代码的内聚性的提高和复用都非常有益。因此测试驱动开发也是一种代码设计的过程。</p>
<p>开发人员通常对编写文档非常厌烦，但要使用、理解别人的代码时通常又希望能有文档进行指导。而测试驱动开发过程中产生的测试用例代码就是对代码的最好的解释。</p>
<p>快乐工作的基础就是对自己有信心，对自己的工作成果有信心。当前很多开发人员却经常在担心：“代码是否正确？”“辛苦编写的代码还有没有严重bug？”“修改的新代码对其他部分有没有影响？”。这种担心甚至导致某些代码应该修改却不敢修改的地步。测试驱动开发提供的测试集就可以作为你信心的来源。</p>
<p>当然测试驱动开发最重要的功能还在于保障代码的正确性，能够迅速发现、定位bug。而迅速发现、定位bug是很多开发人员的梦想。针对关键代码的测试集，以及不断完善的测试用例，为迅速发现、定位bug提供了条件。</p>
<p>我的一段功能非常复杂的代码使用TDD开发完成，真实环境应用中只发现几个bug，而且很快被定位解决。您在应用后，也一定会为那种自信的开发过程，功能不断增加、完善的感觉，迅速发现、定位bug的能力所感染，喜欢这个技术的。</p>
<p>那么是什么样的原理、方法提供上面说的这些好处哪？下面我们就看看TDD的原理。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>测试驱动开发的基本思想就是在开发功能代码之前，先编写测试代码。也就是说在明确要开发某个功能后，首先思考如何对这个功能进行测试，并完成测试代码的编写，然后编写相关的代码满足这些测试用例。然后循环进行添加其他功能，直到完全部功能的开发。</p>
<p>我们这里把这个技术的应用领域从代码编写扩展到整个开发过程。应该对整个开发过程的各个阶段进行测试驱动，首先思考如何对这个阶段进行测试、验证、考核，并编写相关的测试文档，然后开始下一步工作，最后再验证相关的工作。下图是一个比较流行的测试模型：V测试模型。<br><img src="http://i.imgur.com/IbMQX1V.jpg" alt=""></p>
<p>在开发的各个阶段，包括需求分析、概要设计、详细设计、编码过程中都应该考虑相对应的测试工作，完成相关的测试用例的设计、测试方案、测试计划的编写。这里提到的开发阶段只是举例，根据实际的开发活动进行调整。相关的测试文档也不一定是非常详细复杂的文档，或者什么形式，但应该养成测试驱动的习惯。</p>
<p>关于测试模型，还有X测试模型。这个测试模型，我认为，是对详细阶段和编码阶段进行建模，应该说更详细的描述了详细设计和编码阶段的开发行为。及针对某个功能进行对应的测试驱动开发。</p>
<p><img src="http://i.imgur.com/XsKqinL.jpg" alt=""></p>
<p>基本原理应该说非常简单，那么如何进行实际操作哪，下面对开发过程进行详细的介绍。</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>软件开发其他阶段的测试驱动开发，根据测试驱动开发的思想完成对应的测试文档即可。下面针对详细设计和编码阶段进行介绍。</p>
<p>测试驱动开发的基本过程如下：</p>
<p>1） 明确当前要完成的功能。可以记录成一个 TODO 列表。</p>
<p>2） 快速完成针对此功能的测试用例编写。</p>
<p>3） 测试代码编译不通过。</p>
<p>4） 编写对应的功能代码。</p>
<p>5） 测试通过。</p>
<p>6） 对代码进行重构，并保证测试通过。</p>
<p>7） 循环完成所有功能的开发。</p>
<p>为了保证整个测试过程比较快捷、方便，通常可以使用测试框架组织所有的测试用例。一个免费的、优秀的测试框架是 Xunit 系列，几乎所有的语言都有对应的测试框架。我曾经写过一篇文章介绍CppUnit的文章（ <a href="http://www.ibm.com/developerworks/cn/linux/l-cppunit/index.html）。" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/linux/l-cppunit/index.html）。</a></p>
<p>开发过程中，通常把测试代码和功能代码分开存放，这里提供一个简单的测试框架使用例子，您可以通过它了解测试框架的使用。下面是文件列表。</p>
<pre><code>project/                项目主目录
project/test            测试项目主目录
project/test/testSeq.cpp        测试seq_t 的测试文件，对其他功能文件的测试文件复制后修改即可
project/test/testSeq.h
project/test/Makefile            测试项目的 Makefile 
project/test/main.cpp            测试项目的主文件，不需要修改
project/main.cpp                   项目的主文件
project/seq_t.h            功能代码，被测试文件
project/Makefile                   项目的 Makefile
</code></pre><p>主要流程基本如此，但要让你的代码很容易的进行测试，全面又不繁琐的进行测试，还是有很多测试原则和技术需要考虑。</p>
<h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p>测试隔离。不同代码的测试应该相互隔离。对一块代码的测试只考虑此代码的测试，不要考虑其实现细节（比如它使用了其他类的边界条件）。</p>
<p>一顶帽子。开发人员开发过程中要做不同的工作，比如：编写测试代码、开发功能代码、对代码重构等。做不同的事，承担不同的角色。开发人员完成对应的工作时应该保持注意力集中在当前工作上，而不要过多的考虑其他方面的细节，保证头上只有一顶帽子。避免考虑无关细节过多，无谓地增加复杂度。</p>
<p>测试列表。需要测试的功能点很多。应该在任何阶段想添加功能需求问题时，把相关功能点加到测试列表中，然后继续手头工作。然后不断的完成对应的测试用例、功能代码、重构。一是避免疏漏，也避免干扰当前进行的工作。</p>
<p>测试驱动。这个比较核心。完成某个功能，某个类，首先编写测试代码，考虑其如何使用、如何测试。然后在对其进行设计、编码。</p>
<p>先写断言。测试代码编写时，应该首先编写对功能代码的判断用的断言语句，然后编写相应的辅助语句。</p>
<p>可测试性。功能代码设计、开发时应该具有较强的可测试性。其实遵循比较好的设计原则的代码都具备较好的测试性。比如比较高的内聚性，尽量依赖于接口等。</p>
<p>及时重构。无论是功能代码还是测试代码，对结构不合理，重复的代码等情况，在测试通过后，及时进行重构。关于重构，我会另撰文详细分析。<br>小步前进。软件开发是个复杂性非常高的工作，开发过程中要考虑很多东西，包括代码的正确性、可扩展性、性能等等，很多问题都是因为复杂性太大导致的。极限编程提出了一个非常好的思路就是小步前进。把所有的规模大、复杂性高的工作，分解成小的任务来完成。对于一个类来说，一个功能一个功能的完成，如果太困难就再分解。每个功能的完成就走测试代码－功能代码－测试－重构的循环。通过分解降低整个系统开发的复杂性。这样的效果非常明显。几个小的功能代码完成后，大的功能代码几乎是不用调试就可以通过。一个个类方法的实现，很快就看到整个类很快就完成啦。本来感觉很多特性需要增加，很快就会看到没有几个啦。你甚至会为这个速度感到震惊。（我理解，是大幅度减少调试、出错的时间产生的这种速度感）</p>
<h2 id="测试技术"><a href="#测试技术" class="headerlink" title="测试技术"></a>测试技术</h2><h3 id="测试范围、粒度"><a href="#测试范围、粒度" class="headerlink" title="测试范围、粒度"></a>测试范围、粒度</h3><p>对哪些功能进行测试？会不会太繁琐？什么时候可以停止测试？这些问题比较常见。按大师 Kent Benk 的话，对那些你认为应该测试的代码进行测试。就是说，要相信自己的感觉，自己的经验。那些重要的功能、核心的代码就应该重点测试。感到疲劳就应该停下来休息一下。感觉没有必要更详细的测试，就停止本轮测试。<br>测试驱动开发强调测试并不应该是负担，而应该是帮助我们减轻工作量的方法。而对于何时停止编写测试用例，也是应该根据你的经验，功能复杂、核心功能的代码就应该编写更全面、细致的测试用例，否则测试流程即可。<br>测试范围没有静态的标准，同时也应该可以随着时间改变。对于开始没有编写足够的测试的功能代码，随着bug的出现，根据bug补齐相关的测试用例即可。<br>小步前进的原则，要求我们对大的功能块测试时，应该先分拆成更小的功能块进行测试，比如一个类A使用了类B、C，就应该编写到A使用B、C功能的测试代码前，完成对B、C的测试和开发。那么是不是每个小类或者小函数都应该测试哪？我认为没有必要。你应该运用你的经验，对那些可能出问题的地方重点测试，感觉不可能出问题的地方就等它真正出问题的时候再补测试吧。</p>
<h3 id="怎么编写测试用例"><a href="#怎么编写测试用例" class="headerlink" title="怎么编写测试用例"></a>怎么编写测试用例</h3><p>测试用例的编写就用上了传统的测试技术。</p>
<p>操作过程尽量模拟正常使用的过程。</p>
<p>全面的测试用例应该尽量做到分支覆盖，核心代码尽量做到路径覆盖。</p>
<p>测试数据尽量包括：真实数据、边界数据。</p>
<p>测试语句和测试数据应该尽量简单，容易理解。</p>
<p>为了避免对其他代码过多的依赖，可以实现简单的桩函数或桩类（Mock Object）。</p>
<p>如果内部状态非常复杂或者应该判断流程而不是状态，可以通过记录日志字符串的方式进行验证。</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>很多朋友有疑问，“测试代码的正确性如何保障？是写测试代码还是写测试文档？”这样是不是会陷入“鸡生蛋，蛋生鸡”的循环。其实是不会的。通常测试代码通常是非常简单的，通常围绕着某个情况的正确性判断的几个语句，如果太复杂，就应该继续分解啦。而传统的开发过程通常强调测试文档。但随着开发节奏的加快，用户需求的不断变化，维护高层（需求、概要设计）的测试文档可以，更低层的测试文档的成本的确太大了。而且可实时验证功能正确性的测试代码就是对代码最好的文档。</p>
<p>软件开发过程中，除了遵守上面提到的测试驱动开发的几个原则外，一个需要注意的问题就是，谨防过度设计。编写功能代码时应该关注于完成当前功能点，通过测试，使用最简单、直接的方式来编码。过多的考虑后期的扩展，其他功能的添加，无疑增加了过多的复杂性，容易产生问题。应该等到要添加这些特性时在进行详细的测试驱动开发。到时候，有整套测试用例做基础，通过不断重构很容易添加相关特性。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis 和 Memcached 的区别]]></title>
      <url>http://ufdouble.com/2016/07/2016/07/Redis%E5%92%8CMemcached%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      <content type="html"><![CDATA[<p><strong>作者</strong>：<a href="https://github.com/double-qiu" title="DOUBLE" target="_blank" rel="external">DOUBLE</a></p>
<p><strong>时间</strong>：2016年7月4日</p>
<blockquote>
<p>Redis 的作者 Salvatore Sanfilippo 曾经对这两种基于内存的数据存储系统进行过比较：</p>
</blockquote>
<ol>
<li>Redis支持服务器端的数据操作：Redis相比Memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在Memcached里，你需要将数据拿到客户端来进行类似的修改再set回去。这大大增加了网络IO的次数和数据体积。在Redis中，这些复杂的操作通常和一般的GET/SET一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么Redis会是不错的选择。<br>内存使用效率对比：使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。<br>性能对比：由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起Memcached，还是稍有逊色。<br>具体为什么会出现上面的结论，以下为收集到的资料：</li>
<li>内存使用效率对比：使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。</li>
<li>性能对比：由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起Memcached，还是稍有逊色。</li>
</ol>
<p>具体为什么会出现上面的结论，以下为收集到的资料：</p>
<h2 id="1-数据类型支持不同"><a href="#1-数据类型支持不同" class="headerlink" title="1. 数据类型支持不同"></a>1. 数据类型支持不同</h2><p>与Memcached仅支持简单的key-value结构的数据记录不同，Redis支持的数据类型要丰富得多。最为常用的数据类型主要由五种：String、Hash、List、Set和Sorted Set。Redis内部使用一个redisObject对象来表示所有的key和value。redisObject最主要的信息如图所示：<br><img src="http://i.imgur.com/OB5S4P1.jpg" alt=""><br>type代表一个value对象具体是何种数据类型，encoding是不同数据类型在redis内部的存储方式，比如：type=string代表value存储的是一个普通字符串，那么对应的encoding可以是raw或者是int，如果是int则代表实际redis内部是按数值型类存储和表示这个字符串的，当然前提是这个字符串本身可以用数值表示，比如:”123″ “456”这样的字符串。只有打开了Redis的虚拟内存功能，vm字段字段才会真正的分配内存，该功能默认是关闭状态的。</p>
<h3 id="1）String"><a href="#1）String" class="headerlink" title="1）String"></a>1）String</h3><ul>
<li>常用命令：set/get/decr/incr/mget等；</li>
<li>应用场景：String是最常用的一种数据类型，普通的key/value存储都可以归为此类；</li>
<li>实现方式：String在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到incr、 decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。</li>
</ul>
<h3 id="2）Hash"><a href="#2）Hash" class="headerlink" title="2）Hash"></a>2）Hash</h3><ul>
<li>常用命令：hget/hset/hgetall等</li>
<li>应用场景：我们要存储一个用户信息对象数据，其中包括用户ID、用户姓名、年龄和生日，通过用户ID我们希望获取该用户的姓名或者年龄或者生日；</li>
<li>实现方式：Redis的Hash实际是内部存储的Value为一个HashMap，并提供了直接存取这个Map成员的接口。如图所示，Key是用户ID, value是一个Map。这个Map的key是成员的属性名，value是属性值。这样对数据的修改和存取都可以直接通过其内部Map的Key(Redis里称内部Map的key为field), 也就是通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据。当前HashMap的实现有两种方式：当HashMap的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，这时对应的value的redisObject的encoding为zipmap，当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。</li>
<li><img src="http://i.imgur.com/DMqswtk.jpg" alt=""></li>
</ul>
<h3 id="3）List"><a href="#3）List" class="headerlink" title="3）List"></a>3）List</h3><ul>
<li>常用命令：lpush/rpush/lpop/rpop/lrange等；</li>
<li>应用场景：Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现；</li>
<li>实现方式：Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。</li>
</ul>
<h3 id="4）Set"><a href="#4）Set" class="headerlink" title="4）Set"></a>4）Set</h3><ul>
<li>常用命令：sadd/spop/smembers/sunion等；</li>
<li>应用场景：Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的；</li>
<li>实现方式：set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。</li>
</ul>
<h3 id="5）Sorted-Set"><a href="#5）Sorted-Set" class="headerlink" title="5）Sorted Set"></a>5）Sorted Set</h3><ul>
<li>常用命令：zadd/zrange/zrem/zcard等；</li>
<li>应用场景：Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set数据结构，比如twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。</li>
<li>实现方式：Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。</li>
</ul>
<h2 id="2-内存管理机制不同"><a href="#2-内存管理机制不同" class="headerlink" title="2. 内存管理机制不同"></a>2. 内存管理机制不同</h2><p>在Redis中，并不是所有的数据都一直存储在内存中的。这是和Memcached相比一个最大的区别。当物理内存用完时，Redis可以将一些很久没用到的value交换到磁盘。Redis只会缓存所有的key的信息，如果Redis发现内存的使用量超过了某一个阀值，将触发swap的操作，Redis根据“swappability = age*log(size_in_memory)”计算出哪些key对应的value需要swap到磁盘。然后再将这些key对应的value持久化到磁盘中，同时在内存中清除。这种特性使得Redis可以保持超过其机器本身内存大小的数据。当然，机器本身的内存必须要能够保持所有的key，毕竟这些数据是不会进行swap操作的。同时由于Redis将内存中的数据swap到磁盘中的时候，提供服务的主线程和进行swap操作的子线程会共享这部分内存，所以如果更新需要swap的数据，Redis将阻塞这个操作，直到子线程完成swap操作后才可以进行修改。当从Redis中读取数据的时候，如果读取的key对应的value不在内存中，那么Redis就需要从swap文件中加载相应数据，然后再返回给请求方。 这里就存在一个I/O线程池的问题。在默认的情况下，Redis会出现阻塞，即完成所有的swap文件加载后才会相应。这种策略在客户端的数量较小，进行批量操作的时候比较合适。但是如果将Redis应用在一个大型的网站应用程序中，这显然是无法满足大并发的情况的。所以Redis运行我们设置I/O线程池的大小，对需要从swap文件中加载相应数据的读取请求进行并发操作，减少阻塞的时间。</p>
<p>对于像Redis和Memcached这种基于内存的数据库系统来说，内存管理的效率高低是影响系统性能的关键因素。传统C语言中的malloc/free函数是最常用的分配和释放内存的方法，但是这种方法存在着很大的缺陷：首先，对于开发人员来说不匹配的malloc和free容易造成内存泄露；其次频繁调用会造成大量内存碎片无法回收重新利用，降低内存利用率；最后作为系统调用，其系统开销远远大于一般函数调用。所以，为了提高内存的管理效率，高效的内存管理方案都不会直接使用malloc/free调用。Redis和Memcached均使用了自身设计的内存管理机制，但是实现方法存在很大的差异，下面将会对两者的内存管理机制分别进行介绍。</p>
<p>Memcached默认使用Slab Allocation机制管理内存，其主要思想是按照预先规定的大小，将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录，以完全解决内存碎片问题。Slab Allocation机制只为存储外部数据而设计，也就是说所有的key-value数据都存储在Slab Allocation系统里，而Memcached的其它内存请求则通过普通的malloc/free来申请，因为这些请求的数量和频率决定了它们不会对整个系统的性能造成影响Slab Allocation的原理相当简单。 如图所示，它首先从操作系统申请一大块内存，并将其分割成各种尺寸的块Chunk，并把尺寸相同的块分成组Slab Class。其中，Chunk就是用来存储key-value数据的最小单位。每个Slab Class的大小，可以在Memcached启动的时候通过制定Growth Factor来控制。假定图中Growth Factor的取值为1.25，如果第一组Chunk的大小为88个字节，第二组Chunk的大小就为112个字节，依此类推。<br><img src="http://i.imgur.com/hDbyiAp.jpg" alt=""></p>
<p>当Memcached接收到客户端发送过来的数据时首先会根据收到数据的大小选择一个最合适的Slab Class，然后通过查询Memcached保存着的该Slab Class内空闲Chunk的列表就可以找到一个可用于存储数据的Chunk。当一条数据库过期或者丢弃时，该记录所占用的Chunk就可以回收，重新添加到空闲列表中。从以上过程我们可以看出Memcached的内存管理制效率高，而且不会造成内存碎片，但是它最大的缺点就是会导致空间浪费。因为每个Chunk都分配了特定长度的内存空间，所以变长数据无法充分利用这些空间。如图 所示，将100个字节的数据缓存到128个字节的Chunk中，剩余的28个字节就浪费掉了。<br><img src="http://i.imgur.com/XVk7wln.png" alt=""></p>
<p>Redis的内存管理主要通过源码中zmalloc.h和zmalloc.c两个文件来实现的。Redis为了方便内存的管理，在分配一块内存之后，会将这块内存的大小存入内存块的头部。如图所示，real_ptr是redis调用malloc后返回的指针。redis将内存块的大小size存入头部，size所占据的内存大小是已知的，为size_t类型的长度，然后返回ret_ptr。当需要释放内存的时候，ret_ptr被传给内存管理程序。通过ret_ptr，程序可以很容易的算出real_ptr的值，然后将real_ptr传给free释放内存。<br><img src="http://i.imgur.com/OBHfQxo.png" alt=""></p>
<p>Redis通过定义一个数组来记录所有的内存分配情况，这个数组的长度为ZMALLOC_MAX_ALLOC_STAT。数组的每一个元素代表当前程序所分配的内存块的个数，且内存块的大小为该元素的下标。在源码中，这个数组为zmalloc_allocations。zmalloc_allocations[16]代表已经分配的长度为16bytes的内存块的个数。zmalloc.c中有一个静态变量used_memory用来记录当前分配的内存总大小。所以，总的来看，Redis采用的是包装的mallc/free，相较于Memcached的内存管理方法来说，要简单很多。</p>
<h2 id="3-数据持久化支持"><a href="#3-数据持久化支持" class="headerlink" title="3. 数据持久化支持"></a>3. 数据持久化支持</h2><p>Redis虽然是基于内存的存储系统，但是它本身是支持内存数据的持久化的，而且提供两种主要的持久化策略：RDB快照和AOF日志。而memcached是不支持数据持久化操作的。</p>
<p>1）RDB快照<br>Redis支持将当前数据的快照存成一个数据文件的持久化机制，即RDB快照。但是一个持续写入的数据库如何生成快照呢？Redis借助了fork命令的copy on write机制。在生成快照时，将当前进程fork出一个子进程，然后在子进程中循环所有的数据，将数据写成为RDB文件。我们可以通过Redis的save指令来配置RDB快照生成的时机，比如配置10分钟就生成快照，也可以配置有1000次写入就生成快照，也可以多个规则一起实施。这些规则的定义就在Redis的配置文件中，你也可以通过Redis的CONFIG SET命令在Redis运行时设置规则，不需要重启Redis。</p>
<p>Redis的RDB文件不会坏掉，因为其写操作是在一个新进程中进行的，当生成一个新的RDB文件时，Redis生成的子进程会先将数据写到一个临时文件中，然后通过原子性rename系统调用将临时文件重命名为RDB文件，这样在任何时候出现故障，Redis的RDB文件都总是可用的。同时，Redis的RDB文件也是Redis主从同步内部实现中的一环。RDB有他的不足，就是一旦数据库出现问题，那么我们的RDB文件中保存的数据并不是全新的，从上次RDB文件生成到Redis停机这段时间的数据全部丢掉了。在某些业务下，这是可以忍受的。</p>
<p>2）AOF日志</p>
<p>AOF日志的全称是append only file，它是一个追加写入的日志文件。与一般数据库的binlog不同的是，AOF文件是可识别的纯文本，它的内容就是一个个的Redis标准命令。只有那些会导致数据发生修改的命令才会追加到AOF文件。每一条修改数据的命令都生成一条日志，AOF文件会越来越大，所以Redis又提供了一个功能，叫做AOF rewrite。其功能就是重新生成一份AOF文件，新的AOF文件中一条记录的操作只会有一次，而不像一份老文件那样，可能记录了对同一个值的多次操作。其生成过程和RDB类似，也是fork一个进程，直接遍历数据，写入新的AOF临时文件。在写入新文件的过程中，所有的写操作日志还是会写到原来老的AOF文件中，同时还会记录在内存缓冲区中。当重完操作完成后，会将所有缓冲区中的日志一次性写入到临时文件中。然后调用原子性的rename命令用新的AOF文件取代老的AOF文件。</p>
<p>AOF是一个写文件操作，其目的是将操作日志写到磁盘上，所以它也同样会遇到我们上面说的写操作的流程。在Redis中对AOF调用write写入后，通过appendfsync选项来控制调用fsync将其写到磁盘上的时间，下面appendfsync的三个设置项，安全强度逐渐变强。</p>
<ul>
<li><p>appendfsync no 当设置appendfsync为no的时候，Redis不会主动调用fsync去将AOF日志内容同步到磁盘，所以这一切就完全依赖于操作系统的调试了。对大多数Linux操作系统，是每30秒进行一次fsync，将缓冲区中的数据写到磁盘上。</p>
</li>
<li><p>appendfsync everysec 当设置appendfsync为everysec的时候，Redis会默认每隔一秒进行一次fsync调用，将缓冲区中的数据写到磁盘。但是当这一次的fsync调用时长超过1秒时。Redis会采取延迟fsync的策略，再等一秒钟。也就是在两秒后再进行fsync，这一次的fsync就不管会执行多长时间都会进行。这时候由于在fsync时文件描述符会被阻塞，所以当前的写操作就会阻塞。所以结论就是，在绝大多数情况下，Redis会每隔一秒进行一次fsync。在最坏的情况下，两秒钟会进行一次fsync操作。这一操作在大多数数据库系统中被称为group commit，就是组合多次写操作的数据，一次性将日志写到磁盘。</p>
</li>
<li><p>appednfsync always 当设置appendfsync为always时，每一次写操作都会调用一次fsync，这时数据是最安全的，当然，由于每次都会执行fsync，所以其性能也会受到影响。<br>对于一般性的业务需求，建议使用RDB的方式进行持久化，原因是RDB的开销并相比AOF日志要低很多，对于那些无法忍数据丢失的应用，建议使用AOF日志。</p>
</li>
</ul>
<p>对于一般性的业务需求，建议使用RDB的方式进行持久化，原因是RDB的开销并相比AOF日志要低很多，对于那些无法忍数据丢失的应用，建议使用AOF日志。</p>
<h2 id="4-集群管理的不同"><a href="#4-集群管理的不同" class="headerlink" title="4. 集群管理的不同"></a>4. 集群管理的不同</h2><p>Memcached是全内存的数据缓冲系统，Redis虽然支持数据的持久化，但是全内存毕竟才是其高性能的本质。作为基于内存的存储系统来说，机器物理内存的大小就是系统能够容纳的最大数据量。如果需要处理的数据量超过了单台机器的物理内存大小，就需要构建分布式集群来扩展存储能力。</p>
<p>Memcached本身并不支持分布式，因此只能在客户端通过像一致性哈希这样的分布式算法来实现Memcached的分布式存储。下图给出了Memcached的分布式存储实现架构。当客户端向Memcached集群发送数据之前，首先会通过内置的分布式算法计算出该条数据的目标节点，然后数据会直接发送到该节点上存储。但客户端查询数据时，同样要计算出查询数据所在的节点，然后直接向该节点发送查询请求以获取数据。</p>
<p><img src="http://i.imgur.com/jZUPw1w.jpg" alt=""></p>
<p>相较于Memcached只能采用客户端实现分布式存储，Redis更偏向于在服务器端构建分布式存储。最新版本的Redis已经支持了分布式存储功能。Redis Cluster是一个实现了分布式且允许单点故障的Redis高级版本，它没有中心节点，具有线性可伸缩的功能。下图给出Redis Cluster的分布式存储架构，其中节点与节点之间通过二进制协议进行通信，节点与客户端之间通过ascii协议进行通信。在数据的放置策略上，Redis Cluster将整个key的数值域分成4096个哈希槽，每个节点上可以存储一个或多个哈希槽，也就是说当前Redis Cluster支持的最大节点数就是4096。Redis Cluster使用的分布式算法也很简单：crc16( key ) % HASH_SLOTS_NUMBER。<br><img src="http://i.imgur.com/oysYdZ2.jpg" alt=""></p>
<p>为了保证单点故障下的数据可用性，Redis Cluster引入了Master节点和Slave节点。在Redis Cluster中，每个Master节点都会有对应的两个用于冗余的Slave节点。这样在整个集群中，任意两个节点的宕机都不会导致数据的不可用。当Master节点退出后，集群会自动选择一个Slave节点成为新的Master节点。</p>
<p><img src="http://i.imgur.com/Tw5STdh.jpg" alt=""></p>
<p>参考资料：</p>
<ul>
<li><p><a href="http://www.redisdoc.com/en/latest/" target="_blank" rel="external">http://www.redisdoc.com/en/latest/</a></p>
</li>
<li><p><a href="http://memcached.org/" target="_blank" rel="external">http://memcached.org/</a></p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[nginx缓存静态文件搭建详解]]></title>
      <url>http://ufdouble.com/2016/07/2016/07/nginx%E7%BC%93%E5%AD%98%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6.html</url>
      <content type="html"><![CDATA[<p><strong>作者</strong>：<a href="https://github.com/double-qiu" title="DOUBLE" target="_blank" rel="external">DOUBLE</a></p>
<p><strong>时间</strong>：2016年7月4日</p>
<blockquote>
<p>nginx缓存静态文件</p>
</blockquote>
<p>接触nginx的兄弟或多或少都有遇到缓存问题，要么是nginx为什么不缓存，要么就是nginx缓存很快就失效等等问题，在网上找了一遍nginx缓存优先级的文章，大家可以参考下。</p>
<h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p>client端  &lt;——————&gt;   nginx cache &lt;——————&gt;源服务器</p>
<p>经过大量测试发现：nginx的过期顺序是有一个优先级的。下面首先说明各个影响缓存过期的因素：</p>
<p>（1）inactive:在proxy_cache_path配置项中进行配置，说明某个缓存在inactive指定的时间内如果不访问，将会从缓存中删除。</p>
<p>（2）源服务器php页面中生成的响应头中的Expires，生成语句为：header(“Expires: Fri, 07 Sep 2013 08:05:18 GMT”);</p>
<p>（3）源服务器php页面生成的max-age，生成语句为：header(“Cache-Control: max-age=60”);</p>
<p>（4）nginx的配置项 proxy_cache_valid:配置nginx cache中的缓存文件的缓存时间，如果配置项为：proxy_cache_valid 200 304 2m;说<br>明对于状态为200和304的缓存文件的缓存时间是2分钟，两分钟之后再访问该缓存文件时，文件会过期，从而去源服务器重新取数据。<br>其次对需要注意的一点：源服务器的expires和nginx cache的expires配置项的冲突进行说明，场景如下</p>
<p>（1）源服务器端有php文件ta1.php内容如下：</p>
<pre><code>&lt;?php
header(&quot;Expires: Fri, 07 Sep 2013 08:05:18 GMT&quot;);
header(&quot;Last-Modified: &quot;.gmdate(&quot;D, d M Y H:i:s&quot;).&quot; GMT&quot;);
header(&quot;Cache-Control: max-age=60&quot;);
echo&quot;ta1&quot;;
?&gt;
</code></pre><p>（2）在nginx cache服务器端的配置信息如下：</p>
<pre><code>…….
proxy_cache_path /data0/proxy_cache_dir levels=1:2  keys_zone=cache_one:200minactive=5smax_size=30g;
……..

location~.*\.(php|jsp|cgi)$
{
   proxy_read_timeout10s;
   proxy_connect_timeout10s;
   proxy_set_header Host$host;
   proxy_cache_use_stale updating;
   proxy_cache_key$host$uri$is_args$args;
   proxy_cache cache_one;
   #proxy_ignore_headers &quot;Cache-Control&quot;;
   #proxy_hide_header &quot;Cache-Control&quot;;
   #proxy_ignore_headers &quot;Expires&quot;;
   #proxy_hide_header &quot;Expires&quot;;
   proxy_hide_header&quot;Set-Cookie&quot;;
   proxy_ignore_headers&quot;Set-Cookie&quot;;
   #add_header Cache-Control max-age=60;
   add_headerX-Cache&apos;$upstream_cache_status from $server_addr&apos;;
   proxy_cache_valid2003042m;
   #proxy_cache_valid any 0m;
   proxy_pass http://backend_server;
   expires30s;
}
………….
</code></pre><p>从上面两项可以看出nginx cache 服务器中expires的配置是30s，该expires的值直接决定了在浏览器端看到的max-age以及expires的值。而源服务器断的代码中设置的响应头中的max-age为60，expires为Fri, 07 Sep 2013 08:05:18 GMT。这是源服务器的设置于nginx-cache的设置冲突了，那么着两个属性应该怎么设置呢？<br>这时client端的max-age与expires的值按照nginx cache中的expires配置项的设置，即:</p>
<pre><code>Expires Fri,07Sep201208:59:16GMT
Cache-Controlmax-age=30
</code></pre><p>而nginx cache端的缓存的max-age与expire的值按照源服务器上的代码的设置。即：</p>
<pre><code>Expires Fri,07Sep201308:05:18GMT
Cache-Controlmax-age=60
</code></pre><p>现在步入正题：</p>
<p>经过大量测试发现：对缓存的过期与清除起作用的因素的优先级从高到低一次为：<br>inactive配置项、源服务器设置的Expires、源服务器设置的Max-Age、proxy_cache_valid配置项<br>下面通过几个实例对这几个优先级进行说明</p>
<p>实例1：</p>
<p>服务器端php代码：</p>
<pre><code>&lt;?php
header(&quot;Expires: Fri, 07 Sep 2012 08:03:18 GMT&quot;);//其实是3分钟之后
header(&quot;Last-Modified: &quot;.gmdate(&quot;D, d M Y H:i:s&quot;).&quot; GMT&quot;);
header(&quot;Cache-Control: max-age=180&quot;);//2分钟
//header(&quot;Cache-Control: post-check=0, pre-check=0&quot;, false);
echo&quot;ta1&quot;;
?&gt;
</code></pre><p>nginx cache 配置项</p>
<p>inactive 4m//4分钟</p>
<p>proxy_cache_valid 1m//1分钟</p>
<p>现象：第一次访问页面ta1.php之后，各个时间的访问结果：</p>
<p>1分钟之后 ：HIT//这说明valid没有起作用</p>
<p>2分钟之后 ：HIT//这说明 源服务器设置的max-age没有起作用</p>
<p>3分钟之后：MISS//这说明源服务器设置的Expires起作用了</p>
<p>4分钟之后：MISS//这说明inactive起作用了</p>
<p>实例2：</p>
<p>服务器端php代码：</p>
<pre><code>&lt;?php
header(&quot;Expires: Fri, 07 Sep 2012 08:03:18 GMT&quot;);//3分钟之后
header(&quot;Last-Modified: &quot;.gmdate(&quot;D, d M Y H:i:s&quot;).&quot; GMT&quot;);
header(&quot;Cache-Control: max-age=180&quot;);//2分钟
//header(&quot;Cache-Control: post-check=0, pre-check=0&quot;, false);
echo&quot;ta1&quot;;
?&gt;
</code></pre><p>nginx cache 配置项</p>
<p>inactive 10s//10秒钟</p>
<p>proxy_cache_valid 1m//1分钟</p>
<p>现象：第一次访问页面ta1.php之后，各个时间的访问结果：</p>
<p>5秒后访问：HIT</p>
<p>10秒后访问: MISS</p>
<p>15秒后访问：HIT</p>
<p>20秒后访问:MISS</p>
<p>通过实例1和实例2综合分析：如果inactive已经进行了设置，则缓存的过期时间以inactive设置的值为准</p>
<p>实例3：</p>
<p>服务器端php代码：</p>
<pre><code>&lt;?php
header(&quot;Expires: Fri, 07 Sep 1977 08:03:18 GMT&quot;);//直接过期
header(&quot;Last-Modified: &quot;.gmdate(&quot;D, d M Y H:i:s&quot;).&quot; GMT&quot;);
header(&quot;Cache-Control: max-age=120&quot;);//2分钟
//header(&quot;Cache-Control: post-check=0, pre-check=0&quot;, false);
echo&quot;ta1&quot;;
?&gt;
</code></pre><p>nginx cache 配置项</p>
<p>inactive 4m//4分钟</p>
<p>proxy_cache_valid 1m//1分钟</p>
<p>现象：第一次访问页面ta1.php之后，各个时间的访问结果：</p>
<p>每隔一秒访问一次：MISS//这说明源服务器端设置的Expires屏蔽了nginx的valide和源服务器端设置的max-age的作用</p>
<p>实例4：</p>
<p>服务器端php代码：</p>
<pre><code>&lt;?php
header(&quot;Expires: Fri, 07 Sep 2012 08:03:18 GMT&quot;);//3分钟之后
header(&quot;Last-Modified: &quot;.gmdate(&quot;D, d M Y H:i:s&quot;).&quot; GMT&quot;);
header(&quot;Cache-Control: max-age=120&quot;);//2分钟
//header(&quot;Cache-Control: post-check=0, pre-check=0&quot;, false);
echo&quot;ta1&quot;;
?&gt;
</code></pre><p>nginx cache 配置项</p>
<p>inactive 4m//4分钟</p>
<p>proxy_cache_valid 1m//1分钟</p>
<p>现象：第一次访问页面ta1.php之后，各个时间的访问结果：</p>
<p>1分钟之后 ：   HIT//这说明valid没有起作用，因为源服务器设置的Expires将valid的效果屏蔽了</p>
<p>2分钟之后 ：   HIT//这说明 源服务器设置的max-age没有起作用，因为源服务器设置的Expires将max-age屏蔽了</p>
<p>3分钟之后：    MISS//这说明服务器端设置的expires起作用了</p>
<p>通过实例2和实例3的现象说明：如果inactive设置的比较大，在inactive到期之前，如果valid、服务器端设置的expires、服务器端设置的max-<br>age都进行了设置，则以服务器端设置的expires为准。</p>
<p>实例5：</p>
<p>服务器端php代码：</p>
<pre><code>&lt;?php
header(&quot;Expires: Fri, 07 Sep 2012 08:03:18 GMT&quot;);//3分钟之后
header(&quot;Last-Modified: &quot;.gmdate(&quot;D, d M Y H:i:s&quot;).&quot; GMT&quot;);
header(&quot;Cache-Control: max-age=120&quot;);//2分钟
//header(&quot;Cache-Control: post-check=0, pre-check=0&quot;, false);
echo&quot;ta1&quot;;
?&gt;
</code></pre><p>nginx cache 配置项</p>
<p>inactive 4m//4分钟</p>
<p>#下面两行用于消除服务器端配置的Expires响应头的影响</p>
<p>proxy_ignore_headers “Expires”;</p>
<p>proxy_hide_header “Expires”;</p>
<p>proxy_cache_valid 1m//1分钟</p>
<p>现象：第一次访问页面ta1.php之后，各个时间的访问结果：</p>
<p>1分钟之后   HIT //这说明valid的作用已经被服务器端的max-age屏蔽</p>
<p>2分钟之后   MISS//服务器端设置的max-age起作用</p>
<p>实例6：</p>
<p>服务器端php代码：</p>
<pre><code>&lt;?php
header(&quot;Expires: Fri, 07 Sep 2012 08:03:18 GMT&quot;);//3分钟之后
header(&quot;Last-Modified: &quot;.gmdate(&quot;D, d M Y H:i:s&quot;).&quot; GMT&quot;);
header(&quot;Cache-Control: max-age=50&quot;);//50秒钟
//header(&quot;Cache-Control: post-check=0, pre-check=0&quot;, false);
echo&quot;ta1&quot;;
?&gt;
</code></pre><p>nginx cache 配置项</p>
<p>inactive 4m//4分钟</p>
<p>#下面两行用于消除服务器端配置的Expires响应头的影响</p>
<p>proxy_ignore_headers “Expires”;</p>
<p>proxy_hide_header “Expires”;</p>
<p>proxy_cache_valid 2m//2分钟</p>
<p>现象：第一次访问页面ta1.php之后，各个时间的访问结果：</p>
<p>50秒钟之后 ：   MISS//这说明服务器端配置的max-age起作用</p>
<p>1分钟之后 ：   HIT//</p>
<p>100秒钟之后：   MISS//这说明服务器端设置的max-age起作用了</p>
<p>通过实例5和实例6的现象说明：如果inactive设置的比较大，而且在nginx配置文件中取消服务器端Expires对缓存的影响。在同时设置了proxy_cache_valid和服务器端设置了max-age响应头字段的情况下，以服务器端设置的max-age的值为标准进行缓存过期处理。</p>
<p>综上所述：</p>
<p>（1）在同时设置了源服务器端Expires、源服务器端max-age和nginx cahe端的proxy_cache_valid的情况下，以源服务器端设置的Expires的值为标准进行缓存的过期处理</p>
<p>（2）若在nginx中配置了相关配置项，取消原服务器端Expires对缓存的影响，在同时设置了源服务器端Expires、源服务器端max-age和nginx cahe端的proxy_cache_valid的情况下，以源服务器端max-age的值为标准进行缓存的过期处理</p>
<p>（3）若同时取消源服务器端Expires和源服务器端max-age对缓存的影响，则以proxy_cache_valid设置的值为标准进行缓存的过期处理</p>
<p>（4）Inactive的值不受上述三个因素的影响，即第一次请求页面之后，每经过inactvie指定的时间，都要强制进行相应的缓存清理。因此inactive的优先级最高。</p>
<p>（5）所以对缓存过期影响的优先级进行排序为：inactvie、源服务器端Expires、源服务器端max-age、proxy_cache_valid</p>
<p><strong>转自：<a href="http://lmdkfs.blog.163.com/blog/static/7461132420142128311980/" target="_blank" rel="external">http://lmdkfs.blog.163.com/blog/static/7461132420142128311980/</a></strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[个人博客音乐测试]]></title>
      <url>http://ufdouble.com/2016/07/2016/07/muisc.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>音乐测试</p>
</blockquote>
<h2 id="张碧晨-我可以忘记你："><a href="#张碧晨-我可以忘记你：" class="headerlink" title="张碧晨 我可以忘记你："></a>张碧晨 我可以忘记你：</h2><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=416552313&auto=1&height=66"></iframe>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[个人博客图片测试]]></title>
      <url>http://ufdouble.com/2016/07/2016/07/rating.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>图片测试</p>
</blockquote>
<h2 id="关于骑行那些事"><a href="#关于骑行那些事" class="headerlink" title="关于骑行那些事"></a>关于骑行那些事</h2><p><img src="http://i.imgur.com/bwyG01t.jpg" alt=""><br><img src="http://i.imgur.com/CorVKWU.jpg" alt=""><br><img src="http://i.imgur.com/WENVFWW.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[个人博客视频测试]]></title>
      <url>http://ufdouble.com/2016/07/2016/07/video.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>视频测试</p>
</blockquote>
<h2 id="NBA过人集锦-脚踝终结者-Crossover："><a href="#NBA过人集锦-脚踝终结者-Crossover：" class="headerlink" title="NBA过人集锦 脚踝终结者 Crossover："></a>NBA过人集锦 脚踝终结者 Crossover：</h2><iframe height="498" width="510" src="http://player.youku.com/embed/XOTE2NTU3NTA0" frameborder="0" allowfullscreen></iframe>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[个人博客搭建详解（Windows和Mac通用版）]]></title>
      <url>http://ufdouble.com/2016/07/2016/07/fisrtBlog.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>Hexo 是一个基于nodejs 的静态博客网站生成器，作者是来自台湾的 Tommy Chen</p>
</blockquote>
<p>文／diygreen（简书作者）<br>原文链接：<a href="http://www.jianshu.com/p/380290deb8f0#" target="_blank" rel="external">http://www.jianshu.com/p/380290deb8f0#</a><br>著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。</p>
]]></content>
    </entry>
    
  
  
</search>
