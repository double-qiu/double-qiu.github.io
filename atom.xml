<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>闲言碎语</title>
  <subtitle>等一个人，等一个故事</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ufdouble.com/"/>
  <updated>2016-07-04T09:07:29.968Z</updated>
  <id>http://ufdouble.com/</id>
  
  <author>
    <name>DOUBLE</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>敏捷开发</title>
    <link href="http://ufdouble.com/2016/07/04/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    <id>http://ufdouble.com/2016/07/04/敏捷开发/</id>
    <published>2016-07-04T08:42:22.393Z</published>
    <updated>2016-07-04T09:07:29.968Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;现在敏捷开发是越来越火了，人人都在谈敏捷，人人都在学习Scrum和XP…&lt;/p&gt;
&lt;p&gt;为了不落后他人，于是我也开始学习Scrum，今天主要是对我最近阅读的相关资料，根据自己的理解，用自己的话来讲述Scrum中的各个环节，主要目的有两个，一个是进行知识的总结，另外一个是觉得网上很多学习资料的讲述方式让初学者不太容易理解；所以我决定写一篇扫盲性的博文，同时试着也与园内的朋友一起分享交流一下，希望对初学者有帮助。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是敏捷开发？&quot;&gt;&lt;a href=&quot;#什么是敏捷开发？&quot; class=&quot;headerlink&quot; title=&quot;什么是敏捷开发？&quot;&gt;&lt;/a&gt;什么是敏捷开发？&lt;/h2&gt;&lt;p&gt;敏捷开发(Agile Development)是一种以人为核心、迭代、循序渐进的开发方法。&lt;br&gt;怎么理解呢？首先，我们要理解它不是一门技术，它是一种开发方法，也就是一种软件开发的流程，它会指导我们用规定的环节去一步一步完成项目的开发；而这种开发方式的主要驱动核心是人；它采用的是迭代式开发；&lt;/p&gt;
&lt;h2 id=&quot;为什么说是以人为核心？&quot;&gt;&lt;a href=&quot;#为什么说是以人为核心？&quot; class=&quot;headerlink&quot; title=&quot;为什么说是以人为核心？&quot;&gt;&lt;/a&gt;为什么说是以人为核心？&lt;/h2&gt;&lt;p&gt;我们大部分人都学过瀑布开发模型，它是以文档为驱动的，为什么呢？因为在瀑布的整个开发过程中，要写大量的文档，把需求文档写出来后，开发人员都是根据文档进行开发的，一切以文档为依据；而敏捷开发它只写有必要的文档，或尽量少写文档，敏捷开发注重的是人与人之间，面对面的交流，所以它强调以人为核心。&lt;/p&gt;
&lt;h2 id=&quot;什么是迭代？&quot;&gt;&lt;a href=&quot;#什么是迭代？&quot; class=&quot;headerlink&quot; title=&quot;什么是迭代？&quot;&gt;&lt;/a&gt;什么是迭代？&lt;/h2&gt;&lt;p&gt;迭代是指把一个复杂且开发周期很长的开发任务，分解为很多小周期可完成的任务，这样的一个周期就是一次迭代的过程；同时每一次迭代都可以生产或开发出一个可以交付的软件产品。&lt;/p&gt;
&lt;h2 id=&quot;关于Scrum和XP&quot;&gt;&lt;a href=&quot;#关于Scrum和XP&quot; class=&quot;headerlink&quot; title=&quot;关于Scrum和XP&quot;&gt;&lt;/a&gt;关于Scrum和XP&lt;/h2&gt;&lt;p&gt;前面说了敏捷它是一种指导思想或开发方式，但是它没有明确告诉我们到底采用什么样的流程进行开发，而Scrum和XP就是敏捷开发的具体方式了，你可以采用Scrum方式也可以采用XP方式；Scrum和XP的区别是，Scrum偏重于过程，XP则偏重于实践，但是实际中，两者是结合一起应用的，这里我主要讲Scrum。&lt;/p&gt;
&lt;h2 id=&quot;什么是Scrum？&quot;&gt;&lt;a href=&quot;#什么是Scrum？&quot; class=&quot;headerlink&quot; title=&quot;什么是Scrum？&quot;&gt;&lt;/a&gt;什么是Scrum？&lt;/h2&gt;&lt;p&gt;Scrum的英文意思是橄榄球运动的一个专业术语，表示“争球”的动作；把一个开发流程的名字取名为Scrum，我想你一定能想象出你的开发团队在开发一个项目时，大家像打橄榄球一样迅速、富有战斗激情、人人你争我抢地完成它，你一定会感到非常兴奋的。&lt;br&gt;而Scrum就是这样的一个开发流程，运用该流程，你就能看到你团队高效的工作。&lt;/p&gt;
&lt;h2 id=&quot;【Scrum开发流程中的三大角色】&quot;&gt;&lt;a href=&quot;#【Scrum开发流程中的三大角色】&quot; class=&quot;headerlink&quot; title=&quot;【Scrum开发流程中的三大角色】&quot;&gt;&lt;/a&gt;【Scrum开发流程中的三大角色】&lt;/h2&gt;&lt;h3 id=&quot;产品负责人（Product-Owner）&quot;&gt;&lt;a href=&quot;#产品负责人（Product-Owner）&quot; class=&quot;headerlink&quot; title=&quot;产品负责人（Product Owner）&quot;&gt;&lt;/a&gt;产品负责人（Product Owner）&lt;/h3&gt;&lt;p&gt;主要负责确定产品的功能和达到要求的标准，指定软件的发布日期和交付的内容，同时有权力接受或拒绝开发团队的工作成果。&lt;/p&gt;
&lt;h3 id=&quot;流程管理员（Scrum-Master）&quot;&gt;&lt;a href=&quot;#流程管理员（Scrum-Master）&quot; class=&quot;headerlink&quot; title=&quot;流程管理员（Scrum Master）&quot;&gt;&lt;/a&gt;流程管理员（Scrum Master）&lt;/h3&gt;&lt;p&gt;主要负责整个Scrum流程在项目中的顺利实施和进行，以及清除挡在客户和开发工作之间的沟通障碍，使得客户可以直接驱动开发。&lt;/p&gt;
&lt;h3 id=&quot;开发团队（Scrum-Team）&quot;&gt;&lt;a href=&quot;#开发团队（Scrum-Team）&quot; class=&quot;headerlink&quot; title=&quot;开发团队（Scrum Team）&quot;&gt;&lt;/a&gt;开发团队（Scrum Team）&lt;/h3&gt;&lt;p&gt;主要负责软件产品在Scrum规定流程下进行开发工作，人数控制在5~10人左右，每个成员可能负责不同的技术方面，但要求每成员必须要有很强的自我管理能力，同时具有一定的表达能力；成员可以采用任何工作方式，只要能达到Sprint的目标。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scrum流程图&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/LRdmK1w.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面，我们开始讲具体实施流程，但是在讲之前，我还要对一个英文单词进行讲解。&lt;/p&gt;
&lt;h2 id=&quot;什么是Sprint？&quot;&gt;&lt;a href=&quot;#什么是Sprint？&quot; class=&quot;headerlink&quot; title=&quot;什么是Sprint？&quot;&gt;&lt;/a&gt;什么是Sprint？&lt;/h2&gt;&lt;p&gt;Sprint是短距离赛跑的意思，这里面指的是一次迭代，而一次迭代的周期是1个月时间（即4个星期），也就是我们要把一次迭代的开发内容以最快的速度完成它，这个过程我们称它为Sprint。&lt;/p&gt;
&lt;h2 id=&quot;如何进行Scrum开发？&quot;&gt;&lt;a href=&quot;#如何进行Scrum开发？&quot; class=&quot;headerlink&quot; title=&quot;如何进行Scrum开发？&quot;&gt;&lt;/a&gt;如何进行Scrum开发？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;我们首先需要确定一个Product Backlog（按优先顺序排列的一个产品需求列表），这个是由Product Owner 负责的；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Scrum Team根据Product Backlog列表，做工作量的预估和安排；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有了Product Backlog列表，我们需要通过 Sprint Planning Meeting（Sprint计划会议） 来从中挑选出一个Story作为本次迭代完成的目标，这个目标的时间周期是1~4个星期，然后把这个Story进行细化，形成一个Sprint Backlog；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Sprint Backlog是由Scrum Team去完成的，每个成员根据Sprint Backlog再细化成更小的任务（细到每个任务的工作量在2天内能完成）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在Scrum Team完成计划会议上选出的Sprint Backlog过程中，需要进行 Daily Scrum Meeting（每日站立会议），每次会议控制在15分钟左右，每个人都必须发言，并且要向所有成员当面汇报你昨天完成了什么，并且向所有成员承诺你今天要完成什么，同时遇到不能解决的问题也可以提出，每个人回答完成后，要走到黑板前更新自己的 Sprint burn down（Sprint燃尽图）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;做到每日集成，也就是每天都要有一个可以成功编译、并且可以演示的版本；很多人可能还没有用过自动化的每日集成，其实TFS就有这个功能，它可以支持每次有成员进行签入操作的时候，在服务器上自动获取最新版本，然后在服务器中编译，如果通过则马上再执行单元测试代码，如果也全部通过，则将该版本发布，这时一次正式的签入操作才保存到TFS中，中间有任何失败，都会用邮件通知项目管理人员；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当一个Story完成，也就是Sprint Backlog被完成，也就表示一次Sprint完成，这时，我们要进行 Srpint Review Meeting（演示会议），也称为评审会议，产品负责人和客户都要参加（最好本公司老板也参加），每一个Scrum Team的成员都要向他们演示自己完成的软件产品（这个会议非常重要，一定不能取消）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最后就是 Sprint Retrospective Meeting（回顾会议），也称为总结会议，以轮流发言方式进行，每个人都要发言，总结并讨论改进的地方，放入下一轮Sprint的产品需求中；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;下面是运用Scrum开发流程中的一些场景图：&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/3462EkG.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图是一个 Product Backlog 的示例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/o2KWOy1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图就是每日的站立会议了，参会人员可以随意姿势站立，任务看板要保证让每个人看到，当每个人发言完后，要走到任务版前更新自己的燃尽图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/PDe0XDO.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;任务看版包含 未完成、正在做、已完成 的工作状态，假设你今天把一个未完成的工作已经完成，那么你要把小卡片从未完成区域贴到已完成区域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/iaCmWmj.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;每个人的工作进度和完成情况都是公开的，如果有一个人的工作任务在某一个位置放了好几天，大家都能发现他的工作进度出现了什么问题（成员人数最好是5~7个，这样每人可以使用一种专用颜色的标签纸，一眼就可以从任务版看出谁的工作进度快，谁的工作进度慢）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/nFVvNbr.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图可不是扑克牌，它是计划纸牌，它的作用是防止项目在开发过程中，被某些人所领导。&lt;/p&gt;
&lt;p&gt;怎么用的呢？比如A程序员开发一个功能，需要5个小时，B程序员认为只需要半小时，那他们各自取相应的牌，藏在手中，最后摊牌，如果时间差距很大，那么A和B就可以讨论A为什么要5个小时…&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;敏捷开发的4句宣言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个体与交互 胜过 过程与工具&lt;/p&gt;
&lt;p&gt;可以工作的软件 胜过 面面俱到的文挡&lt;/p&gt;
&lt;p&gt;客户协作 胜过 合同谈判&lt;/p&gt;
&lt;p&gt;响应变化 胜过 遵循计划&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;现在敏捷开发是越来越火了，人人都在谈敏捷，人人都在学习Scrum和XP…&lt;/p&gt;
&lt;p&gt;为了不落后他人，于是我也开始学习Scrum，今天主要是对我最近阅读的相关资料，根据自己的理解，用自己的话来讲述Scrum中的各个环节，主要目的有两个，一个是进行
    
    </summary>
    
      <category term="软件工程" scheme="http://ufdouble.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="开发方法论" scheme="http://ufdouble.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    
      <category term="软件工程" scheme="http://ufdouble.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="方法论" scheme="http://ufdouble.com/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>nginx缓存静态文件搭建详解</title>
    <link href="http://ufdouble.com/2016/07/04/nginx%E7%BC%93%E5%AD%98%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/"/>
    <id>http://ufdouble.com/2016/07/04/nginx缓存静态文件/</id>
    <published>2016-07-04T08:18:12.941Z</published>
    <updated>2016-07-04T08:36:07.518Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;nginx缓存静态文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接触nginx的兄弟或多或少都有遇到缓存问题，要么是nginx为什么不缓存，要么就是nginx缓存很快就失效等等问题，在网上找了一遍nginx缓存优先级的文章，大家可以参考下。&lt;/p&gt;
&lt;h2 id=&quot;架构图&quot;&gt;&lt;a href=&quot;#架构图&quot; class=&quot;headerlink&quot; title=&quot;架构图&quot;&gt;&lt;/a&gt;架构图&lt;/h2&gt;&lt;p&gt;client端  &amp;lt;——————&amp;gt;   nginx cache &amp;lt;——————&amp;gt;源服务器&lt;/p&gt;
&lt;p&gt;经过大量测试发现：nginx的过期顺序是有一个优先级的。下面首先说明各个影响缓存过期的因素：&lt;/p&gt;
&lt;p&gt;（1）inactive:在proxy_cache_path配置项中进行配置，说明某个缓存在inactive指定的时间内如果不访问，将会从缓存中删除。&lt;/p&gt;
&lt;p&gt;（2）源服务器php页面中生成的响应头中的Expires，生成语句为：header(“Expires: Fri, 07 Sep 2013 08:05:18 GMT”);&lt;/p&gt;
&lt;p&gt;（3）源服务器php页面生成的max-age，生成语句为：header(“Cache-Control: max-age=60”);&lt;/p&gt;
&lt;p&gt;（4）nginx的配置项 proxy_cache_valid:配置nginx cache中的缓存文件的缓存时间，如果配置项为：proxy_cache_valid 200 304 2m;说&lt;br&gt;明对于状态为200和304的缓存文件的缓存时间是2分钟，两分钟之后再访问该缓存文件时，文件会过期，从而去源服务器重新取数据。&lt;br&gt;其次对需要注意的一点：源服务器的expires和nginx cache的expires配置项的冲突进行说明，场景如下&lt;/p&gt;
&lt;p&gt;（1）源服务器端有php文件ta1.php内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
header(&amp;quot;Expires: Fri, 07 Sep 2013 08:05:18 GMT&amp;quot;);
header(&amp;quot;Last-Modified: &amp;quot;.gmdate(&amp;quot;D, d M Y H:i:s&amp;quot;).&amp;quot; GMT&amp;quot;);
header(&amp;quot;Cache-Control: max-age=60&amp;quot;);
echo&amp;quot;ta1&amp;quot;;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;（2）在nginx cache服务器端的配置信息如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;…….
proxy_cache_path /data0/proxy_cache_dir levels=1:2  keys_zone=cache_one:200minactive=5smax_size=30g;
……..

location~.*\.(php|jsp|cgi)$
{
   proxy_read_timeout10s;
   proxy_connect_timeout10s;
   proxy_set_header Host$host;
   proxy_cache_use_stale updating;
   proxy_cache_key$host$uri$is_args$args;
   proxy_cache cache_one;
   #proxy_ignore_headers &amp;quot;Cache-Control&amp;quot;;
   #proxy_hide_header &amp;quot;Cache-Control&amp;quot;;
   #proxy_ignore_headers &amp;quot;Expires&amp;quot;;
   #proxy_hide_header &amp;quot;Expires&amp;quot;;
   proxy_hide_header&amp;quot;Set-Cookie&amp;quot;;
   proxy_ignore_headers&amp;quot;Set-Cookie&amp;quot;;
   #add_header Cache-Control max-age=60;
   add_headerX-Cache&amp;apos;$upstream_cache_status from $server_addr&amp;apos;;
   proxy_cache_valid2003042m;
   #proxy_cache_valid any 0m;
   proxy_pass http://backend_server;
   expires30s;
}
………….
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从上面两项可以看出nginx cache 服务器中expires的配置是30s，该expires的值直接决定了在浏览器端看到的max-age以及expires的值。而源服务器断的代码中设置的响应头中的max-age为60，expires为Fri, 07 Sep 2013 08:05:18 GMT。这是源服务器的设置于nginx-cache的设置冲突了，那么着两个属性应该怎么设置呢？&lt;br&gt;这时client端的max-age与expires的值按照nginx cache中的expires配置项的设置，即:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Expires Fri,07Sep201208:59:16GMT
Cache-Controlmax-age=30
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而nginx cache端的缓存的max-age与expire的值按照源服务器上的代码的设置。即：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Expires Fri,07Sep201308:05:18GMT
Cache-Controlmax-age=60
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在步入正题：&lt;/p&gt;
&lt;p&gt;经过大量测试发现：对缓存的过期与清除起作用的因素的优先级从高到低一次为：&lt;br&gt;inactive配置项、源服务器设置的Expires、源服务器设置的Max-Age、proxy_cache_valid配置项&lt;br&gt;下面通过几个实例对这几个优先级进行说明&lt;/p&gt;
&lt;p&gt;实例1：&lt;/p&gt;
&lt;p&gt;服务器端php代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
header(&amp;quot;Expires: Fri, 07 Sep 2012 08:03:18 GMT&amp;quot;);//其实是3分钟之后
header(&amp;quot;Last-Modified: &amp;quot;.gmdate(&amp;quot;D, d M Y H:i:s&amp;quot;).&amp;quot; GMT&amp;quot;);
header(&amp;quot;Cache-Control: max-age=180&amp;quot;);//2分钟
//header(&amp;quot;Cache-Control: post-check=0, pre-check=0&amp;quot;, false);
echo&amp;quot;ta1&amp;quot;;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;nginx cache 配置项&lt;/p&gt;
&lt;p&gt;inactive 4m//4分钟&lt;/p&gt;
&lt;p&gt;proxy_cache_valid 1m//1分钟&lt;/p&gt;
&lt;p&gt;现象：第一次访问页面ta1.php之后，各个时间的访问结果：&lt;/p&gt;
&lt;p&gt;1分钟之后 ：HIT//这说明valid没有起作用&lt;/p&gt;
&lt;p&gt;2分钟之后 ：HIT//这说明 源服务器设置的max-age没有起作用&lt;/p&gt;
&lt;p&gt;3分钟之后：MISS//这说明源服务器设置的Expires起作用了&lt;/p&gt;
&lt;p&gt;4分钟之后：MISS//这说明inactive起作用了&lt;/p&gt;
&lt;p&gt;实例2：&lt;/p&gt;
&lt;p&gt;服务器端php代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
header(&amp;quot;Expires: Fri, 07 Sep 2012 08:03:18 GMT&amp;quot;);//3分钟之后
header(&amp;quot;Last-Modified: &amp;quot;.gmdate(&amp;quot;D, d M Y H:i:s&amp;quot;).&amp;quot; GMT&amp;quot;);
header(&amp;quot;Cache-Control: max-age=180&amp;quot;);//2分钟
//header(&amp;quot;Cache-Control: post-check=0, pre-check=0&amp;quot;, false);
echo&amp;quot;ta1&amp;quot;;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;nginx cache 配置项&lt;/p&gt;
&lt;p&gt;inactive 10s//10秒钟&lt;/p&gt;
&lt;p&gt;proxy_cache_valid 1m//1分钟&lt;/p&gt;
&lt;p&gt;现象：第一次访问页面ta1.php之后，各个时间的访问结果：&lt;/p&gt;
&lt;p&gt;5秒后访问：HIT&lt;/p&gt;
&lt;p&gt;10秒后访问: MISS&lt;/p&gt;
&lt;p&gt;15秒后访问：HIT&lt;/p&gt;
&lt;p&gt;20秒后访问:MISS&lt;/p&gt;
&lt;p&gt;通过实例1和实例2综合分析：如果inactive已经进行了设置，则缓存的过期时间以inactive设置的值为准&lt;/p&gt;
&lt;p&gt;实例3：&lt;/p&gt;
&lt;p&gt;服务器端php代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
header(&amp;quot;Expires: Fri, 07 Sep 1977 08:03:18 GMT&amp;quot;);//直接过期
header(&amp;quot;Last-Modified: &amp;quot;.gmdate(&amp;quot;D, d M Y H:i:s&amp;quot;).&amp;quot; GMT&amp;quot;);
header(&amp;quot;Cache-Control: max-age=120&amp;quot;);//2分钟
//header(&amp;quot;Cache-Control: post-check=0, pre-check=0&amp;quot;, false);
echo&amp;quot;ta1&amp;quot;;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;nginx cache 配置项&lt;/p&gt;
&lt;p&gt;inactive 4m//4分钟&lt;/p&gt;
&lt;p&gt;proxy_cache_valid 1m//1分钟&lt;/p&gt;
&lt;p&gt;现象：第一次访问页面ta1.php之后，各个时间的访问结果：&lt;/p&gt;
&lt;p&gt;每隔一秒访问一次：MISS//这说明源服务器端设置的Expires屏蔽了nginx的valide和源服务器端设置的max-age的作用&lt;/p&gt;
&lt;p&gt;实例4：&lt;/p&gt;
&lt;p&gt;服务器端php代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
header(&amp;quot;Expires: Fri, 07 Sep 2012 08:03:18 GMT&amp;quot;);//3分钟之后
header(&amp;quot;Last-Modified: &amp;quot;.gmdate(&amp;quot;D, d M Y H:i:s&amp;quot;).&amp;quot; GMT&amp;quot;);
header(&amp;quot;Cache-Control: max-age=120&amp;quot;);//2分钟
//header(&amp;quot;Cache-Control: post-check=0, pre-check=0&amp;quot;, false);
echo&amp;quot;ta1&amp;quot;;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;nginx cache 配置项&lt;/p&gt;
&lt;p&gt;inactive 4m//4分钟&lt;/p&gt;
&lt;p&gt;proxy_cache_valid 1m//1分钟&lt;/p&gt;
&lt;p&gt;现象：第一次访问页面ta1.php之后，各个时间的访问结果：&lt;/p&gt;
&lt;p&gt;1分钟之后 ：   HIT//这说明valid没有起作用，因为源服务器设置的Expires将valid的效果屏蔽了&lt;/p&gt;
&lt;p&gt;2分钟之后 ：   HIT//这说明 源服务器设置的max-age没有起作用，因为源服务器设置的Expires将max-age屏蔽了&lt;/p&gt;
&lt;p&gt;3分钟之后：    MISS//这说明服务器端设置的expires起作用了&lt;/p&gt;
&lt;p&gt;通过实例2和实例3的现象说明：如果inactive设置的比较大，在inactive到期之前，如果valid、服务器端设置的expires、服务器端设置的max-&lt;br&gt;age都进行了设置，则以服务器端设置的expires为准。&lt;/p&gt;
&lt;p&gt;实例5：&lt;/p&gt;
&lt;p&gt;服务器端php代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
header(&amp;quot;Expires: Fri, 07 Sep 2012 08:03:18 GMT&amp;quot;);//3分钟之后
header(&amp;quot;Last-Modified: &amp;quot;.gmdate(&amp;quot;D, d M Y H:i:s&amp;quot;).&amp;quot; GMT&amp;quot;);
header(&amp;quot;Cache-Control: max-age=120&amp;quot;);//2分钟
//header(&amp;quot;Cache-Control: post-check=0, pre-check=0&amp;quot;, false);
echo&amp;quot;ta1&amp;quot;;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;nginx cache 配置项&lt;/p&gt;
&lt;p&gt;inactive 4m//4分钟&lt;/p&gt;
&lt;p&gt;#下面两行用于消除服务器端配置的Expires响应头的影响&lt;/p&gt;
&lt;p&gt;proxy_ignore_headers “Expires”;&lt;/p&gt;
&lt;p&gt;proxy_hide_header “Expires”;&lt;/p&gt;
&lt;p&gt;proxy_cache_valid 1m//1分钟&lt;/p&gt;
&lt;p&gt;现象：第一次访问页面ta1.php之后，各个时间的访问结果：&lt;/p&gt;
&lt;p&gt;1分钟之后   HIT //这说明valid的作用已经被服务器端的max-age屏蔽&lt;/p&gt;
&lt;p&gt;2分钟之后   MISS//服务器端设置的max-age起作用&lt;/p&gt;
&lt;p&gt;实例6：&lt;/p&gt;
&lt;p&gt;服务器端php代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
header(&amp;quot;Expires: Fri, 07 Sep 2012 08:03:18 GMT&amp;quot;);//3分钟之后
header(&amp;quot;Last-Modified: &amp;quot;.gmdate(&amp;quot;D, d M Y H:i:s&amp;quot;).&amp;quot; GMT&amp;quot;);
header(&amp;quot;Cache-Control: max-age=50&amp;quot;);//50秒钟
//header(&amp;quot;Cache-Control: post-check=0, pre-check=0&amp;quot;, false);
echo&amp;quot;ta1&amp;quot;;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;nginx cache 配置项&lt;/p&gt;
&lt;p&gt;inactive 4m//4分钟&lt;/p&gt;
&lt;p&gt;#下面两行用于消除服务器端配置的Expires响应头的影响&lt;/p&gt;
&lt;p&gt;proxy_ignore_headers “Expires”;&lt;/p&gt;
&lt;p&gt;proxy_hide_header “Expires”;&lt;/p&gt;
&lt;p&gt;proxy_cache_valid 2m//2分钟&lt;/p&gt;
&lt;p&gt;现象：第一次访问页面ta1.php之后，各个时间的访问结果：&lt;/p&gt;
&lt;p&gt;50秒钟之后 ：   MISS//这说明服务器端配置的max-age起作用&lt;/p&gt;
&lt;p&gt;1分钟之后 ：   HIT//&lt;/p&gt;
&lt;p&gt;100秒钟之后：   MISS//这说明服务器端设置的max-age起作用了&lt;/p&gt;
&lt;p&gt;通过实例5和实例6的现象说明：如果inactive设置的比较大，而且在nginx配置文件中取消服务器端Expires对缓存的影响。在同时设置了proxy_cache_valid和服务器端设置了max-age响应头字段的情况下，以服务器端设置的max-age的值为标准进行缓存过期处理。&lt;/p&gt;
&lt;p&gt;综上所述：&lt;/p&gt;
&lt;p&gt;（1）在同时设置了源服务器端Expires、源服务器端max-age和nginx cahe端的proxy_cache_valid的情况下，以源服务器端设置的Expires的值为标准进行缓存的过期处理&lt;/p&gt;
&lt;p&gt;（2）若在nginx中配置了相关配置项，取消原服务器端Expires对缓存的影响，在同时设置了源服务器端Expires、源服务器端max-age和nginx cahe端的proxy_cache_valid的情况下，以源服务器端max-age的值为标准进行缓存的过期处理&lt;/p&gt;
&lt;p&gt;（3）若同时取消源服务器端Expires和源服务器端max-age对缓存的影响，则以proxy_cache_valid设置的值为标准进行缓存的过期处理&lt;/p&gt;
&lt;p&gt;（4）Inactive的值不受上述三个因素的影响，即第一次请求页面之后，每经过inactvie指定的时间，都要强制进行相应的缓存清理。因此inactive的优先级最高。&lt;/p&gt;
&lt;p&gt;（5）所以对缓存过期影响的优先级进行排序为：inactvie、源服务器端Expires、源服务器端max-age、proxy_cache_valid&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转自：&lt;a href=&quot;http://lmdkfs.blog.163.com/blog/static/7461132420142128311980/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://lmdkfs.blog.163.com/blog/static/7461132420142128311980/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;nginx缓存静态文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接触nginx的兄弟或多或少都有遇到缓存问题，要么是nginx为什么不缓存，要么就是nginx缓存很快就失效等等问题，在网上找了一遍nginx缓存优先级的文章，大家可以参考下。&lt;/p
    
    </summary>
    
      <category term="服务端技术" scheme="http://ufdouble.com/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
      <category term="nginx" scheme="http://ufdouble.com/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8A%80%E6%9C%AF/nginx/"/>
    
    
      <category term="nginx" scheme="http://ufdouble.com/tags/nginx/"/>
    
      <category term="java" scheme="http://ufdouble.com/tags/java/"/>
    
      <category term="缓存" scheme="http://ufdouble.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>个人博客图片测试</title>
    <link href="http://ufdouble.com/2016/07/03/rating/"/>
    <id>http://ufdouble.com/2016/07/03/rating/</id>
    <published>2016-07-03T04:32:01.153Z</published>
    <updated>2016-07-03T04:42:37.558Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;图片测试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;关于骑行那些事&quot;&gt;&lt;a href=&quot;#关于骑行那些事&quot; class=&quot;headerlink&quot; title=&quot;关于骑行那些事&quot;&gt;&lt;/a&gt;关于骑行那些事&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/bwyG01t.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/CorVKWU.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/WENVFWW.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;图片测试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;关于骑行那些事&quot;&gt;&lt;a href=&quot;#关于骑行那些事&quot; class=&quot;headerlink&quot; title=&quot;关于骑行那些事&quot;&gt;&lt;/a&gt;关于骑行那些事&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;h
    
    </summary>
    
      <category term="个人爱好" scheme="http://ufdouble.com/categories/%E4%B8%AA%E4%BA%BA%E7%88%B1%E5%A5%BD/"/>
    
      <category term="骑行" scheme="http://ufdouble.com/categories/%E4%B8%AA%E4%BA%BA%E7%88%B1%E5%A5%BD/%E9%AA%91%E8%A1%8C/"/>
    
    
      <category term="骑行" scheme="http://ufdouble.com/tags/%E9%AA%91%E8%A1%8C/"/>
    
      <category term="山地车" scheme="http://ufdouble.com/tags/%E5%B1%B1%E5%9C%B0%E8%BD%A6/"/>
    
  </entry>
  
  <entry>
    <title>个人博客音乐测试</title>
    <link href="http://ufdouble.com/2016/07/03/muisc/"/>
    <id>http://ufdouble.com/2016/07/03/muisc/</id>
    <published>2016-07-03T03:58:28.151Z</published>
    <updated>2016-07-03T04:23:33.591Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;音乐测试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;张碧晨-我可以忘记你：&quot;&gt;&lt;a href=&quot;#张碧晨-我可以忘记你：&quot; class=&quot;headerlink&quot; title=&quot;张碧晨 我可以忘记你：&quot;&gt;&lt;/a&gt;张碧晨 我可以忘记你：&lt;/h2&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;http://music.163.com/outchain/player?type=2&amp;id=416552313&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;音乐测试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;张碧晨-我可以忘记你：&quot;&gt;&lt;a href=&quot;#张碧晨-我可以忘记你：&quot; class=&quot;headerlink&quot; title=&quot;张碧晨 我可以忘记你：&quot;&gt;&lt;/a&gt;张碧晨 我可以忘记你：&lt;/h
    
    </summary>
    
      <category term="个人爱好" scheme="http://ufdouble.com/categories/%E4%B8%AA%E4%BA%BA%E7%88%B1%E5%A5%BD/"/>
    
      <category term="音乐" scheme="http://ufdouble.com/categories/%E4%B8%AA%E4%BA%BA%E7%88%B1%E5%A5%BD/%E9%9F%B3%E4%B9%90/"/>
    
    
      <category term="张碧晨" scheme="http://ufdouble.com/tags/%E5%BC%A0%E7%A2%A7%E6%99%A8/"/>
    
      <category term="音乐" scheme="http://ufdouble.com/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>个人博客视频测试</title>
    <link href="http://ufdouble.com/2016/07/03/video/"/>
    <id>http://ufdouble.com/2016/07/03/video/</id>
    <published>2016-07-03T03:38:37.537Z</published>
    <updated>2016-07-03T04:21:19.336Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;视频测试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;NBA过人集锦-脚踝终结者-Crossover：&quot;&gt;&lt;a href=&quot;#NBA过人集锦-脚踝终结者-Crossover：&quot; class=&quot;headerlink&quot; title=&quot;NBA过人集锦 脚踝终结者 Crossover：&quot;&gt;&lt;/a&gt;NBA过人集锦 脚踝终结者 Crossover：&lt;/h2&gt;&lt;iframe height=&quot;498&quot; width=&quot;510&quot; src=&quot;http://player.youku.com/embed/XOTE2NTU3NTA0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;视频测试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;NBA过人集锦-脚踝终结者-Crossover：&quot;&gt;&lt;a href=&quot;#NBA过人集锦-脚踝终结者-Crossover：&quot; class=&quot;headerlink&quot; title=&quot;NBA过人
    
    </summary>
    
      <category term="个人爱好" scheme="http://ufdouble.com/categories/%E4%B8%AA%E4%BA%BA%E7%88%B1%E5%A5%BD/"/>
    
      <category term="篮球" scheme="http://ufdouble.com/categories/%E4%B8%AA%E4%BA%BA%E7%88%B1%E5%A5%BD/%E7%AF%AE%E7%90%83/"/>
    
    
      <category term="篮球" scheme="http://ufdouble.com/tags/%E7%AF%AE%E7%90%83/"/>
    
      <category term="NBA" scheme="http://ufdouble.com/tags/NBA/"/>
    
  </entry>
  
  <entry>
    <title>个人博客搭建详解（Windows和Mac通用版）</title>
    <link href="http://ufdouble.com/2016/07/03/fisrtBlog/"/>
    <id>http://ufdouble.com/2016/07/03/fisrtBlog/</id>
    <published>2016-07-03T00:25:00.720Z</published>
    <updated>2016-07-03T03:37:30.660Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;Hexo 是一个基于nodejs 的静态博客网站生成器，作者是来自台湾的 Tommy Chen&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文／diygreen（简书作者）&lt;br&gt;原文链接：&lt;a href=&quot;http://www.jianshu.com/p/380290deb8f0#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/380290deb8f0#&lt;/a&gt;&lt;br&gt;著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Hexo 是一个基于nodejs 的静态博客网站生成器，作者是来自台湾的 Tommy Chen&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文／diygreen（简书作者）&lt;br&gt;原文链接：&lt;a href=&quot;http://www.jianshu.co
    
    </summary>
    
      <category term="实用技术" scheme="http://ufdouble.com/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E6%9C%AF/"/>
    
      <category term="个人博客" scheme="http://ufdouble.com/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E6%9C%AF/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="实用" scheme="http://ufdouble.com/tags/%E5%AE%9E%E7%94%A8/"/>
    
      <category term="个人博客" scheme="http://ufdouble.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
